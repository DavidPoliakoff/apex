/* required for Doxygen */

/** @file */ 

/** \mainpage APEX: Autonomic Performance Environment for eXascale

\section overview Overview

One of the key components of the XPRESS project is a new approach to
performance observation, measurement, analysis and runtime decision making in
order to optimize performance. The particular challenges of accurately
measuring the performance characteristics of ParalleX applications requires a
new approach to parallel performance observation. The standard model of
multiple operating system processes and threads observing themselves in a
first-person manner while writing out performance profiles or traces for
offline analysis will not adequately capture the full execution context, nor
provide opportunities for runtime adaptation within OpenX. The approach taken
in the XPRESS project is a new performance measurement system, called
(Autonomic Performance Environment for eXascale). APEX will include methods for
information sharing between the layers of the software stack, from the hardware
through operating and runtime systems, all the way to domain specific or legacy
applications. The performance measurement components will incorporate relevant
information across stack layers, with merging of third-person performance
observation of node-level and global resources, remote processes, and both
operating and runtime system threads.

\section introduction Introduction
\subsection interfaces Interfaces

APEX has both C and C++ interfaces. While the C interface can be used
for either, some C++ applications prefer to work with namespaces (i.e.
apex::*) rather than prefixes (i.e. apex_*). All functionality is
supported through both interfaces, and the C interface contains inlined
implementations of the C++ code.

The direct links to each API are here:
<ul>
<li>C API : @ref apex.h </li>
<li>C++ API : @ref apex </li>
</dl>

\section installation Installation
\subsection external_dependencies External Software Dependencies
\subsubsection required_dependencies Required Software Dependencies
<dl>
<dt>CMake version 2.8.12 or newer</dt>
<dd></dd>
<dt>Boost 1.54.0</dt>
<dd>With the headers and the following libraries: system thread timer chrono</dd>
</dl>

\subsubsection optional_dependencies Optional Software Dependencies
<dl>

<dt>MPI</dt>
<dd>If your application / runtime uses MPI for distributed communication,
enabling MPI support allows APEX to provide global performance data across
all nodes. The MPI exchanges use MPI2 asynchronous communication, so your
MPI implementation needs to at least support the MPI2 interface. CMake 
should auto-detect the MPI settings from the mpicxx compiler in your path.
</dd>
<dt>TAU</dt>
<dd>For collecting post-mortem profile or trace files.</dd>
<dt>RCR</dt>
<dd>For accessing system-level privileged information, such as power measurements
(on some systems).</dd>
<dt>Tcmalloc</dt>
<dd>For faster memory allocation.</dd>
<dt>PAPI</dt>
<dd>For Hardware Counter support (without TAU).</dd>
<dt>BinUtils</dt>
<dd>For resolving function addresses to name, file, line number(s).</dd>
<dt>BinUtils Demangle support</dt>
<dd>Used with BinUtils to demangle C++ function names.</dd>
<dt>Zlib</dt>
<dd>Used by some BinUtils implementations.</dd>
</dl>
<dl>
<dt>Doxygen</dt>
<dd>Used to make this documentation.</dd>
</dl>

\subsection getting Getting the Code

The code is hosted at https://code.google.com/p/xpress-apex/.  To get the code,
follow the instructions here: https://code.google.com/p/xpress-apex/source/checkout

\subsection bootstrapping Bootstrapping: the "easy" way

The code contains a "bootstrap-configs" directory with a few examples. 

<ol>
<li> Start with the example closest to your system </li/>
<li> Copy that example in the same bootstrap-configs directory </li/>
<li> Edit as necessary </li/>
<li> Bootstrap with "./bootstrap-configs/bootstrap-xxx.sh" </li/>
</ol>

\subsection custom Custom Builds

APEX uses CMake for the build process. In most cases, CMake will use both
options passed in with -D values and environment variables. APEX can be
configured by using CMake directly - just create your own build directory
and run cmake or ccmake with the appropriate configuration settings.

\section variables Environment Variables

Apex uses a number of environment variables to control its behavior at
runtime. These variables are:

<dl>

<dt>APEX_TAU</dt> 
<dd>If APEX is configured with TAU support, this will enable the TAU profiling
support. 0 is disabled, 1 is enabled.</dd>

<dt>APEX_POLICY</dt> 
<dd>Enable policy processing in the APEX event listener. 0 is
  disabled, 1 is enabled.</dd>

<dt>APEX_CONCURRENCY</dt> 
<dd>Enable concurrency measurement as an APEX event listener.
  Concurrency will be collected in each process, and a gnuplot will be 
  produced at the end of execution showing the sampled concurrency during
  execution.
  0 is disabled, 1 is enabled.</dd>

<dt>APEX_CONCURRENCY_PERIOD</dt> 
<dd>Set the concurrency measurement period. The
  unit is in microseconds.</dd>

<dt>APEX_SCREEN_OUTPUT</dt> 
<dd>When the program terminates, the main process will
  dump a measurement summary to the screen. 
  0 is disabled, 1 is enabled.</dd>

<dt>APEX_PROFILE_OUTPUT</dt> 
<dd>When the program terminates, all processes will
  write TAU profiles to disk. 
  0 is disabled, 1 is enabled (process summary only), 2 is enabled 
  (per-thread measurement detail).</dd>

</dl>

\section examples Usage Examples

There are several examples in src/examples. Each of the examples is usually
constructed as a CMake test, but it also serves as a usage example as well.

\subsection DemoC DemoC

This example is a simple example of a C program using APEX.

\subsection DemoCpp DemoCpp

This example is a simple example of a C++ program using APEX.

\subsection Matmult Matmult

This example is a simple example of a C++ program using APEX.
This example spawns three threads, and all four threads perform
a matrix multiplication.

\subsection MPIGlobalTest MPIGlobalTest

This example demonstrates how MPI one-sided communication is used
to perform global reductions of performance data at runtime. This
example uses the code in src/comm/mpi to perform the reduction.
This example is provided as an example for other distributed runtimes
to implement the API in @ref src/comm/apex_global.h.

\subsection MPITest MPITest

This is a simple example using C++ and MPI.

\subsection Overhead Overhead

This is a simple example used to test the overhead of timing a task.

\subsection PolicyEngineCppExample PolicyEngineCppExample

This is a C++ example of a runtime policy. In this example, a periodic
policy and an event based policy are created.

\subsection PolicyEngineExample PolicyEngineExample

This is a C example of a runtime policy. In this example, a periodic
policy and an event based policy are created.

\subsection TestITT TestITT

This is an example to demonstrate how APEX implements the Intel
Instrumentation and Tracing Technology API. If an existing application
uses the ITT interface, APEX can use that rather than adding additional
instrumentaion.

\subsection TestGetPower TestGetPower

This is an example that demonstrates the ability to read power and energy
from user-space on the Cray XC30. APEX will also have the ability to read
power and energy from either PAPI, RCR or libmsr in the future, and on
supported platforms.

\subsection TestReset TestReset

This is an example that demonstrates the use of resetting counters
and timers in APEX. This is especially useful when policies cause changes
in runtime or application behavior, and the policy wants to check the 
efficacy of the changed behavior in subsequent iterations.

\subsection TestThreads TestThreads

This is a simple example that demonstrates the use of APEX in multithreaded
environments.

\section acknowledgements Acknowledgements

Support for this work was provided through Scientific Discovery through
Advanced Computing (SciDAC) program funded by U.S. Department of Energy, Office
of Science, Advanced Scientific Computing Research (and Basic Energy
Sciences/Biological and Environmental Research/High Energy Physics/Fusion
Energy Sciences/Nuclear Physics) under award numbers DE-SC0008638,
DE-SC0008704, DE-FG02-11ER26050 and DE-SC0006925.

**/
