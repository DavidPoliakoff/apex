{
    "docs": [
        {
            "location": "/", 
            "text": "APEX: Autonomic Performance Environment for eXascale\n\n\nOne of the key components of the XPRESS project is a new approach to performance observation, measurement, analysis and runtime decision making in order to optimize performance. The particular challenges of accurately measuring the performance characteristics of ParalleX \n[1]\n applications (as well as other asynchronous multitasking runtime architectures) requires a new approach to parallel performance observation. The standard model of multiple operating system processes and threads observing themselves in a first-person manner while writing out performance profiles or traces for offline analysis will not adequately capture the full execution context, nor provide opportunities for runtime adaptation within OpenX. The approach taken in the XPRESS project is a new performance measurement system, called (Autonomic Performance Environment for eXascale). APEX includes methods for information sharing between the layers of the software stack, from the hardware through operating and runtime systems, all the way to domain specific or legacy applications. The performance measurement components incorporate relevant information across stack layers, with merging of third-person performance observation of node-level and global resources, remote processes, and both operating and runtime system threads.  For a complete academic description of APEX, see the publication \"APEX: An Autonomic Performance Environment for eXascale\" \n[2]\n.\n\n\nIn short, APEX is an introspection and runtime adaptation library for asynchronous multitasking runtime systems. However, APEX is not \nonly\n useful for AMT/AMR runtimes running on future exascale systems - it can be used by any application wanting to perform runtime adaptation to deal with heterogeneous and/or variable environments.\n\n\nIntrospection\n\n\nAPEX provides an API for measuring actions within a runtime. The API includes methods for timer start/stop, as well as sampled counter values. APEX is designed to be integrated into a runtime, library and/or application and provide performance introspection for the purpose of runtime adaptation. While APEX \ncan\n provide rudimentary post-mortem performance analysis measurement, there are many other performance measurement tools that perform that task much better (such as TAU http://tau.uoregon.edu).  That said, APEX includes an event listener that integrates with the TAU measurement system, so APEX events can be forwarded to TAU and collected in a TAU profile and/or trace to be used for post-mortem performance anlaysis.\n\n\nRuntime Adaptation\n\n\nAPEX provides a mechanism for dynamic runtime behavior, either for autotuning or adaptation to changing environment.  The infrastruture that provides the adaptation is the Policy Engine, which executes policies either periodically or triggered by events. The policies have access to the performance state as observed by the APEX introspection API. APEX is integrated with Active Harmony (http://www.dyninst.org/harmony) to provide dynamic search for autotuning.\n\n\nReferences\n\n\n\n\n Thomas Sterling, Daniel Kogler, Matthew Anderson, and Maciej Brodowicz. \"SLOWER: A performance model for Exascale computing\". \nSupercomputing Frontiers and Innovations\n, 1:42\u201357, September 2014. \nhttp://superfri.org/superfri/article/view/10\n\n\n Kevin A. Huck, Allan Porterfield, Nick Chaimov, Hartmut Kaiser, Allen D. Malony, Thomas Sterling, Rob Fowler. \"An Autonomic Performance Environment for eXascale\", \nJournal of Supercomputing Frontiers and Innovations\n, 2015. \nhttp://superfri.org/superfri/article/view/64", 
            "title": "Home"
        }, 
        {
            "location": "/#apex-autonomic-performance-environment-for-exascale", 
            "text": "One of the key components of the XPRESS project is a new approach to performance observation, measurement, analysis and runtime decision making in order to optimize performance. The particular challenges of accurately measuring the performance characteristics of ParalleX  [1]  applications (as well as other asynchronous multitasking runtime architectures) requires a new approach to parallel performance observation. The standard model of multiple operating system processes and threads observing themselves in a first-person manner while writing out performance profiles or traces for offline analysis will not adequately capture the full execution context, nor provide opportunities for runtime adaptation within OpenX. The approach taken in the XPRESS project is a new performance measurement system, called (Autonomic Performance Environment for eXascale). APEX includes methods for information sharing between the layers of the software stack, from the hardware through operating and runtime systems, all the way to domain specific or legacy applications. The performance measurement components incorporate relevant information across stack layers, with merging of third-person performance observation of node-level and global resources, remote processes, and both operating and runtime system threads.  For a complete academic description of APEX, see the publication \"APEX: An Autonomic Performance Environment for eXascale\"  [2] .  In short, APEX is an introspection and runtime adaptation library for asynchronous multitasking runtime systems. However, APEX is not  only  useful for AMT/AMR runtimes running on future exascale systems - it can be used by any application wanting to perform runtime adaptation to deal with heterogeneous and/or variable environments.", 
            "title": "APEX: Autonomic Performance Environment for eXascale"
        }, 
        {
            "location": "/#introspection", 
            "text": "APEX provides an API for measuring actions within a runtime. The API includes methods for timer start/stop, as well as sampled counter values. APEX is designed to be integrated into a runtime, library and/or application and provide performance introspection for the purpose of runtime adaptation. While APEX  can  provide rudimentary post-mortem performance analysis measurement, there are many other performance measurement tools that perform that task much better (such as TAU http://tau.uoregon.edu).  That said, APEX includes an event listener that integrates with the TAU measurement system, so APEX events can be forwarded to TAU and collected in a TAU profile and/or trace to be used for post-mortem performance anlaysis.", 
            "title": "Introspection"
        }, 
        {
            "location": "/#runtime-adaptation", 
            "text": "APEX provides a mechanism for dynamic runtime behavior, either for autotuning or adaptation to changing environment.  The infrastruture that provides the adaptation is the Policy Engine, which executes policies either periodically or triggered by events. The policies have access to the performance state as observed by the APEX introspection API. APEX is integrated with Active Harmony (http://www.dyninst.org/harmony) to provide dynamic search for autotuning.", 
            "title": "Runtime Adaptation"
        }, 
        {
            "location": "/#references", 
            "text": "Thomas Sterling, Daniel Kogler, Matthew Anderson, and Maciej Brodowicz. \"SLOWER: A performance model for Exascale computing\".  Supercomputing Frontiers and Innovations , 1:42\u201357, September 2014.  http://superfri.org/superfri/article/view/10   Kevin A. Huck, Allan Porterfield, Nick Chaimov, Hartmut Kaiser, Allen D. Malony, Thomas Sterling, Rob Fowler. \"An Autonomic Performance Environment for eXascale\",  Journal of Supercomputing Frontiers and Innovations , 2015.  http://superfri.org/superfri/article/view/64", 
            "title": "References"
        }, 
        {
            "location": "/feature/", 
            "text": "APEX: Motivation\n\n\nFrequently, software components or even entire applications run into a situation where the context of the execution environment has changed in some way (or does not meet assumptions). In those situations, the software requires some mechanism for evaluating its own performance and that of the underlying runtime system, operating system and hardware. The types of adaptation that the software wants to do could include:\n\n\n\n\nControlling concurrency\n\n\nto improve energy efficiency\n\n\nfor performance\n\n\n\n\n\n\nParametric variability\n\n\nadjust the decomposition granularity for this machine / dataset\n\n\nchoose a different algorithm for better performance/accuracy\n\n\nchoose a different preconditioner for better performance/accuracy\n\n\nchoose a different solver for better performance/accuracy\n\n\n\n\n\n\nLoad Balancing\n\n\nwhen to perform AGAS migration?\n\n\nwhen to perform repartitioning?\n\n\nwhen to perform data exchanges?\n\n\n\n\n\n\nParallel Algorithms (for_each\u2026) - choose a different execution model\n\n\nseparate \nwhat\n from \nhow\n\n\n\n\n\n\nAddress the \u201cSLOW(ER)\u201d performance model\n\n\navoid \nS\ntarvation\n\n\nreduce \nL\natency\n\n\nreduce \nO\nverhead\n\n\nreduce \nW\naiting\n\n\nreduce \nE\nnergy consumption\n\n\nimprove \nR\nesiliency\n\n\n\n\n\n\n\n\nAPEX provides both \nperformance awareness\n and \nperformance adaptation\n.\n\n\n\n\nAPEX provides top-down and bottom-up performance mapping and feedback.\n\n\nAPEX exposes node-wide resource utilization data and analysis, energy consumption, and health information in real time\n\n\nSoftware can subsequently associate performance state with policy for feedback control\n\n\n\n\n\n\nAPEX introspection\n\n\nOS: track system resources, utilization, job contention, overhead\n\n\nRuntime (HPX, HPX-5, OpenMP...): track threads, queues, concurrency, remote operations, parcels, memory management\n\n\nApplication timer / counter observation\n\n\n\n\n\n\n\n\n\n\nAbove: APEX architecture diagram (when linked with an HPX application). The application and runtime send events to the APEX instrumentation API, which updates the performance state. The Policy Engine executes policies that change application behavior based on rule outcomes.\n\n\nIntrospection\n\n\nAPEX collects data through \ninspectors\n. The synchronous data collection uses an event API and event \nlisteners\n. The API includes events for:\n\n\n\n\nInitialize, terminate, new thread \n\n\nadded to the HPX thread scheduler\n\n\nadded to the HPX-5 thread scheduler\n\n\nadded to the OpenMP runtime using the OMPT interface\n\n\nadded to the pthread runtime by wrapping the pthread API calls\n\n\n\n\n\n\nTimer start, stop, yield, resume \n\n\nadded to HPX task scheduler\n\n\nadded to HPX-5 task scheduler\n\n\nadded to the OpenMP runtime using the OMPT interface\n\n\nadded to the pthread runtime by wrapping the pthread API calls\n\n\n\n\n\n\nSampled values\n\n\ncounters from HPX, HPX-5\n\n\n\n\n\n\nCustom events (meta-events)\n\n\nuseful for triggering policies\n\n\n\n\n\n\n\n\nAsynchonous data collection does not rely on events, but occurs periodically.  APEX exploits access to performance data from lower stack components (i.e. the runtime) or by reading from the RCR blackboard (i.e., power, energy). Other operating system and hardware health data is collected through other interfaces:\n\n\n\n\n/proc/stat\n\n\n/proc/cpuinfo\n\n\n/proc/meminfo\n\n\n/proc/net/dev\n\n\n/proc/self/status\n\n\nlm_sensors\n\n\npower measurements \n\n\n\n\nEvent Listeners\n\n\nThere are a number of listeners in APEX that are triggered by the events passed in through the API. For example, the \nProfiling Listener\n records events related to maintaining the performance state.\n\n\n\n\nStart Event: records the name/address of the timer, gets a timestamp (using rdtsc), returns a profiler handle\n\n\nStop Event: gets a timestamp, puts the profiler object in a queue for back-end processing and returns\n\n\nSample Event: put the name \n value in the queue\n\n\n\n\nInternally to APEX, there is an asynchronous consumer thread that processes profiler objects and samples to build a performance profile (in HPX, this thread is processed/scheduled as an HPX thread/task).\n\n\nThe TAU Listener (used for postmortem analysis) synchronously passes all measurement events to TAU to build an offline profile or trace. TAU will also capture any other events for which it is configured, including MPI, memory, file I/O, etc.\n\n\nThe concurrency listener (also used for postmortem analysis) maintains a timeline of total concurrency, periodically sampled from  within APEX.\n\n\n\n\nStart event: push timer ID on stack\n\n\nStop event: pop timer ID off stack\n\n\n\n\nAn asynchronous consumer thread periodically logs the current timer for each thread. This thread will output a concurrency data report and gnuplot script at APEX termination. \n\n\nPolicy Listener\n\n\nPolicies are rules that decide on outcomes based on observed state. \nTriggered policies are invoked by introspection API events.\nPeriodic policies are run periodically on asynchronous thread.\nPolices are registered with the Policy Engine at program startup by runtime code and/or from the application.\nApplications, runtimes, and the OS can register callback functions to be executed. \nCallback functions define the policy rules - \u201cIf x \n y then...(take some action!)\u201d.\n\n\n\n\nEnables runtime adaptation using introspection data\n\n\nEngages actuators across stack layers\n\n\nIs also used to involve online auto-tuning support", 
            "title": "Feature Overview"
        }, 
        {
            "location": "/feature/#apex-motivation", 
            "text": "Frequently, software components or even entire applications run into a situation where the context of the execution environment has changed in some way (or does not meet assumptions). In those situations, the software requires some mechanism for evaluating its own performance and that of the underlying runtime system, operating system and hardware. The types of adaptation that the software wants to do could include:   Controlling concurrency  to improve energy efficiency  for performance    Parametric variability  adjust the decomposition granularity for this machine / dataset  choose a different algorithm for better performance/accuracy  choose a different preconditioner for better performance/accuracy  choose a different solver for better performance/accuracy    Load Balancing  when to perform AGAS migration?  when to perform repartitioning?  when to perform data exchanges?    Parallel Algorithms (for_each\u2026) - choose a different execution model  separate  what  from  how    Address the \u201cSLOW(ER)\u201d performance model  avoid  S tarvation  reduce  L atency  reduce  O verhead  reduce  W aiting  reduce  E nergy consumption  improve  R esiliency     APEX provides both  performance awareness  and  performance adaptation .   APEX provides top-down and bottom-up performance mapping and feedback.  APEX exposes node-wide resource utilization data and analysis, energy consumption, and health information in real time  Software can subsequently associate performance state with policy for feedback control    APEX introspection  OS: track system resources, utilization, job contention, overhead  Runtime (HPX, HPX-5, OpenMP...): track threads, queues, concurrency, remote operations, parcels, memory management  Application timer / counter observation      Above: APEX architecture diagram (when linked with an HPX application). The application and runtime send events to the APEX instrumentation API, which updates the performance state. The Policy Engine executes policies that change application behavior based on rule outcomes.", 
            "title": "APEX: Motivation"
        }, 
        {
            "location": "/feature/#introspection", 
            "text": "APEX collects data through  inspectors . The synchronous data collection uses an event API and event  listeners . The API includes events for:   Initialize, terminate, new thread   added to the HPX thread scheduler  added to the HPX-5 thread scheduler  added to the OpenMP runtime using the OMPT interface  added to the pthread runtime by wrapping the pthread API calls    Timer start, stop, yield, resume   added to HPX task scheduler  added to HPX-5 task scheduler  added to the OpenMP runtime using the OMPT interface  added to the pthread runtime by wrapping the pthread API calls    Sampled values  counters from HPX, HPX-5    Custom events (meta-events)  useful for triggering policies     Asynchonous data collection does not rely on events, but occurs periodically.  APEX exploits access to performance data from lower stack components (i.e. the runtime) or by reading from the RCR blackboard (i.e., power, energy). Other operating system and hardware health data is collected through other interfaces:   /proc/stat  /proc/cpuinfo  /proc/meminfo  /proc/net/dev  /proc/self/status  lm_sensors  power measurements", 
            "title": "Introspection"
        }, 
        {
            "location": "/feature/#event-listeners", 
            "text": "There are a number of listeners in APEX that are triggered by the events passed in through the API. For example, the  Profiling Listener  records events related to maintaining the performance state.   Start Event: records the name/address of the timer, gets a timestamp (using rdtsc), returns a profiler handle  Stop Event: gets a timestamp, puts the profiler object in a queue for back-end processing and returns  Sample Event: put the name   value in the queue   Internally to APEX, there is an asynchronous consumer thread that processes profiler objects and samples to build a performance profile (in HPX, this thread is processed/scheduled as an HPX thread/task).  The TAU Listener (used for postmortem analysis) synchronously passes all measurement events to TAU to build an offline profile or trace. TAU will also capture any other events for which it is configured, including MPI, memory, file I/O, etc.  The concurrency listener (also used for postmortem analysis) maintains a timeline of total concurrency, periodically sampled from  within APEX.   Start event: push timer ID on stack  Stop event: pop timer ID off stack   An asynchronous consumer thread periodically logs the current timer for each thread. This thread will output a concurrency data report and gnuplot script at APEX termination.", 
            "title": "Event Listeners"
        }, 
        {
            "location": "/feature/#policy-listener", 
            "text": "Policies are rules that decide on outcomes based on observed state. \nTriggered policies are invoked by introspection API events.\nPeriodic policies are run periodically on asynchronous thread.\nPolices are registered with the Policy Engine at program startup by runtime code and/or from the application.\nApplications, runtimes, and the OS can register callback functions to be executed. \nCallback functions define the policy rules - \u201cIf x   y then...(take some action!)\u201d.   Enables runtime adaptation using introspection data  Engages actuators across stack layers  Is also used to involve online auto-tuning support", 
            "title": "Policy Listener"
        }, 
        {
            "location": "/install/", 
            "text": "Downloading APEX\n\n\nAPEX is open source, and available on Github at \nhttp//github.com/khuck/xpress-apex\n.\n\n\nFor stability, most users will want to download the most recent release of APEX (for example, v0.1):\n\n\nwget https://github.com/khuck/xpress-apex/archive/v0.1.tar.gz\ntar -xvzf v0.1.tar.gz\ncd xpress-apex-0.1\n\n\n\n\nOther users may want to work with the most recent code available, in which case you can clone the git repo:\n\n\ngit clone https://github.com/khuck/xpress-apex.git\ncd xpress-apex\n\n\n\n\nInstallation Option 1: Configuring and building APEX with bootstrap scripts\n\n\nThis option is useful for HPC resources where a configuration script already exists, such as Edison@NERSC, Cori@NERSC, Babbage@NERSC, etc.  To use this option, copy and modify ./bootstrap-configs/bootstrap-$arch.sh as necessary, and run it.\n\n\nInstallation Option 2: Configuring and building APEX with CMake directly (recommended for most users)\n\n\nAPEX is built with CMake. The minimum CMake settings needed for APEX are:\n\n\n\n\n-DBOOST_ROOT= the path to a Boost installation, 1.54 or newer\n\n\n-DCMAKE_INSTALL_PREFIX= some path to an installation location\n\n\n-DCMAKE_BUILD_TYPE= one of Release, Debug, or RelWithDebInfo (recommended)\n\n\n\n\nNote:\n \nIf the BOOST_ROOT environment variable is set to a working Boost installation directory, CMake will find it automatically. If Boost is not installed locally, use the -DBUILD_BOOST=TRUE option, which will automatically download and build Boost as a subproject of APEX.\n\n\nThe process for building APEX is:\n\n\n1) Get the code (see above)\n\n\n2) Enter the repo directory, make a build directory:\n\n\ncd xpress-apex-0.1\nmkdir build\ncd build\n\n\n\n\n3) configure using CMake:\n\n\ncmake -DBOOST_ROOT=\npath-to-boost\n -DCMAKE_INSTALL_PREFIX=\ninstallation-path\n -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n\n\n\n\n4) build with make:\n\n\nmake\nmake test\nmake doc\nmake install\n\n\n\n\nOther CMake settings, depending on your needs/wants\n\n\nNote 1:\n \nThe \nrecommended\n packages include:\n\n\n\n\nActive Harmony\n - for autotuning policies\n\n\nOMPT\n - if OpenMP support is required (\nSee the OpenMP use case\n for an example)\n\n\nBinutils/BFD\n - if your runtime/application uses instruction addresses to identify timers, e.g. HPX-5 and OpenMP\n\n\nTAU\n \nor\n \nPAPI\n - if you want post-mortem performance analysis (\nSee the TAU use case\n for an example) or your policies will require hardware counters (\nSee the PAPI use case\n for an example)\n\n\nJEMalloc/TCMalloc\n - if your application is not already using a heap manager - see Note 2, below\n\n\n\n\nNote 2:\n \nTCMalloc or JEMalloc will speed up memory allocations \nsignificantly\n in APEX. HOWEVER, If your application already uses TCMalloc or JEMalloc, \nDO NOT\n configure APEX with TCMalloc or JEMalloc. They will be included at application link time, and may conflict with the version detected by and linked into APEX.\n\n\nThere are several utility libraries that provide additional functionality in APEX. Not all libraries are required, but some are recommended.  For the following options, the default values are in \nitalics\n.\n\n\n\n\n-DBUILD_BOOST=\n\n  TRUE or \nFALSE\n.  In the event that Boost isn't pre-installed on your system, this option forces CMake to download and build Boost as part of the APEX project.\n\n\n-DUSE_ACTIVEHARMONY=\n\n  \nTRUE\n or FALSE.  Active Harmony is a library that intelligently searches for parametric combinations to support adapting to heterogeneous and changing environments.  For more information, see \nhttp://www.dyninst.org/harmony\n.  APEX uses Active Harmony for runtime adaptation.\n\n\n-DACTIVEHARMONY_ROOT=\n\n  the path to Active Harmony, or set the ACTIVEHARMONY_ROOT environment variable before running cmake.  It should be noted that if Active Harmony is not specified and -DUSE_ACTIVEHARMONY is TRUE or not set, APEX will download and build Active Harmony as a CMake project. To disable Active Harmony entirely, specify -DUSE_ACTIVEHARMONY=FALSE.\n\n\n-DBUILD_ACTIVEHARMONY=\n\n  TRUE or \nFALSE\n.  Whether or not Active Harmony is installed on the system, this option forces CMake to automatically download and build Active Harmony as part of the APEX project.\n\n\n-DUSE_OMPT=\n\n  TRUE or \nFALSE\n.  OMPT is a proposed standard for OpenMP runtimes to provide callback hooks to performance tools. For more information, see \nhttp://openmp.org/mp-documents/ompt-tr2.pdf\n.  APEX has support for most OMPT OpenMP trace events. See \nthe OpenMP use case\n for an example.\n\n\n-DOMPT_ROOT=\n\n  the path to OMPT, or set the OMPT_ROOT environment variable before running cmake.\n\n\n-DBUILD_OMPT=\n\n  TRUE or \nFALSE\n. Whether or not an OpenMP library with OMPT support is found by CMake, this option forces CMake to automatically download and build an OpenMP runtime with OMPT support as part of the APEX project.\n\n\n-DUSE_BFD=\n\n  TRUE or \nFALSE\n.  APEX uses libbfd to convert instruction addresses to source code locations. BFD support is useful for generating human-readable output for summaries and concurrency graphs. Libbfd is not required for runtime adaptation.\n\n\n-DBFD_ROOT=\n\n  path to Binutils, or set the BFD_ROOT environment variable.\n\n\n-DBUILD_BFD=\n\n  TRUE or FALSE.  Whether or not binutils is found by CMake, this option forces CMake to automatically download and build binutils as part of the APEX project.\n\n\n-DUSE_TAU=\n\n  TRUE or \nFALSE\n.  TAU (Tuning and Analysis Utilities) is a performance measurement and analysis framework for large scale parallel applications. For more information see \nhttp://tau.uoregon.edu\n.  APEX uses TAU to generate profiles for post-mortem performance analysis. See \nthe TAU use case\n for an example.\n\n\n-DTAU_ROOT=\n\n  path to TAU, or set the TAU_ROOT environment variable before running cmake.\n\n\n-DTAU_ARCH=\n\n  the TAU architecture, like x86_64, craycnl, mic_linux, bgq, etc.\n\n\n-DTAU_OPTIONS=\n\n  a TAU configuration with thread support, like -pthread or -icpc-pthread.\n\n\n-DUSE_RCR=\n\n  TRUE or \nFALSE\n.  RCR (Resource Centric Reflection) is a library for system monitoring of resources that require root access.  For more information, see \nhttp://www.renci.org/wp-content/pub/techreports/TR-10-01.pdf\n.  APEX uses RCR to access 'uncore' counters and system health information such as power and energy counters.\n\n\n-DRCR_ROOT=\n\n  the path to RCR, or set the RCR_ROOT environment variable.\n\n\n-DUSE_TCMALLOC=\n\n  TRUE or \nFALSE\n.  TCMalloc is a heap management library distributed as part of Google perftools. For more information, see \nhttps://github.com/gperftools/gperftools\n.  TCMalloc provides faster memory performance in multithreaded environments.\n\n\n-DGPERFTOOLS_ROOT=\n\n  path to gperftools (TCMalloc), or set the GPERFTOOLS_ROOT environment variable before running cmake.\n\n\n-DUSE_JEMALLOC=\n\n  TRUE or \nFALSE\n.  JEMalloc is a heap management library.  For more information, see \nhttp://www.canonware.com/jemalloc/\n.  JEMalloc provides faster memory performance in multithreaded environments.\n\n\n-DJEMALLOC_ROOT=\n\n  path to JEMalloc, or set the JEMALLOC_ROOT environment variable before running cmake.\n\n\n-DUSE_PAPI=\n\n  TRUE or \nFALSE\n.  PAPI (Performance Application Programming Interface) provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors.  For more information, see \nhttp://icl.cs.utk.edu/papi/\n.  APEX uses PAPI to optionally collect hardware counters for timed events.\n\n\n-DPAPI_ROOT=\n\n  some path to PAPI, or set the PAPI_ROOT environment variable before running cmake. See \nthe PAPI use case\n for an example.\n\n\n-DUSE_LM_SENSORS=\n\n  TRUE or \nFALSE\n. Lm_sensors (Linux Monitoring Sensors) is a library for monitoring hardware temperatures and fan speeds. For more information, see \nhttps://en.wikipedia.org/wiki/Lm_sensors\n.  APEX uses lm_sensors to monitor hardware, where available.\n\n\n-DBUILD_EXAMPLES=\n\n  TRUE or \nFALSE\n. Whether or not to build the application examples in APEX.\n\n\n-DBUILD_TESTS=\n\n  \nTRUE\n or FALSE. Whether or not to build the APEX unit tests.\n\n\n-DCMAKE_C_COMPILER=\n\n  \ngcc\n\n\n-DCMAKE_CXX_COMPILER=\n\n  \ng++\n\n\n-DCMAKE_BUILD_TYPE=\n\n  Release, \nDebug\n, RelWithDebInfo. Unfortunately, the cmake default (when not specified) is Debug. For faster performance, configure APEX to build RelWithDebInfo or Release.\n\n\n-DBUILD_SHARED_LIBS=\n\n  TRUE or FALSE\n\n\n-DUSE_MPI=\n\n  TRUE or \nFALSE\n. Whether to build MPI global support and related examples.\n\n\n-DMPI_C_INCLUDE_PATH=\n\n  path to MPI headers\n\n\n-DMPI_CXX_INCLUDE_PATH=\n\n  path to MPI headers\n\n\n-DMPI_C_LIBRARIES=\n\n  paths to MPI libraries, library names\n\n\n-DMPI_CXX_LIBRARIES=\n\n  paths to MPI libraries, library names\n\n\n-DMPI_C_COMPILER=\n\n  mpicc\n\n\n-DMPI_CXX_COMPILER=\n\n  mpicxx", 
            "title": "Getting Started"
        }, 
        {
            "location": "/install/#downloading-apex", 
            "text": "APEX is open source, and available on Github at  http//github.com/khuck/xpress-apex .  For stability, most users will want to download the most recent release of APEX (for example, v0.1):  wget https://github.com/khuck/xpress-apex/archive/v0.1.tar.gz\ntar -xvzf v0.1.tar.gz\ncd xpress-apex-0.1  Other users may want to work with the most recent code available, in which case you can clone the git repo:  git clone https://github.com/khuck/xpress-apex.git\ncd xpress-apex", 
            "title": "Downloading APEX"
        }, 
        {
            "location": "/install/#installation-option-1-configuring-and-building-apex-with-bootstrap-scripts", 
            "text": "This option is useful for HPC resources where a configuration script already exists, such as Edison@NERSC, Cori@NERSC, Babbage@NERSC, etc.  To use this option, copy and modify ./bootstrap-configs/bootstrap-$arch.sh as necessary, and run it.", 
            "title": "Installation Option 1: Configuring and building APEX with bootstrap scripts"
        }, 
        {
            "location": "/install/#installation-option-2-configuring-and-building-apex-with-cmake-directly-recommended-for-most-users", 
            "text": "APEX is built with CMake. The minimum CMake settings needed for APEX are:   -DBOOST_ROOT= the path to a Boost installation, 1.54 or newer  -DCMAKE_INSTALL_PREFIX= some path to an installation location  -DCMAKE_BUILD_TYPE= one of Release, Debug, or RelWithDebInfo (recommended)   Note:   If the BOOST_ROOT environment variable is set to a working Boost installation directory, CMake will find it automatically. If Boost is not installed locally, use the -DBUILD_BOOST=TRUE option, which will automatically download and build Boost as a subproject of APEX.  The process for building APEX is:  1) Get the code (see above)  2) Enter the repo directory, make a build directory:  cd xpress-apex-0.1\nmkdir build\ncd build  3) configure using CMake:  cmake -DBOOST_ROOT= path-to-boost  -DCMAKE_INSTALL_PREFIX= installation-path  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..  4) build with make:  make\nmake test\nmake doc\nmake install", 
            "title": "Installation Option 2: Configuring and building APEX with CMake directly (recommended for most users)"
        }, 
        {
            "location": "/install/#other-cmake-settings-depending-on-your-needswants", 
            "text": "Note 1:   The  recommended  packages include:   Active Harmony  - for autotuning policies  OMPT  - if OpenMP support is required ( See the OpenMP use case  for an example)  Binutils/BFD  - if your runtime/application uses instruction addresses to identify timers, e.g. HPX-5 and OpenMP  TAU   or   PAPI  - if you want post-mortem performance analysis ( See the TAU use case  for an example) or your policies will require hardware counters ( See the PAPI use case  for an example)  JEMalloc/TCMalloc  - if your application is not already using a heap manager - see Note 2, below   Note 2:   TCMalloc or JEMalloc will speed up memory allocations  significantly  in APEX. HOWEVER, If your application already uses TCMalloc or JEMalloc,  DO NOT  configure APEX with TCMalloc or JEMalloc. They will be included at application link time, and may conflict with the version detected by and linked into APEX.  There are several utility libraries that provide additional functionality in APEX. Not all libraries are required, but some are recommended.  For the following options, the default values are in  italics .   -DBUILD_BOOST= \n  TRUE or  FALSE .  In the event that Boost isn't pre-installed on your system, this option forces CMake to download and build Boost as part of the APEX project.  -DUSE_ACTIVEHARMONY= \n   TRUE  or FALSE.  Active Harmony is a library that intelligently searches for parametric combinations to support adapting to heterogeneous and changing environments.  For more information, see  http://www.dyninst.org/harmony .  APEX uses Active Harmony for runtime adaptation.  -DACTIVEHARMONY_ROOT= \n  the path to Active Harmony, or set the ACTIVEHARMONY_ROOT environment variable before running cmake.  It should be noted that if Active Harmony is not specified and -DUSE_ACTIVEHARMONY is TRUE or not set, APEX will download and build Active Harmony as a CMake project. To disable Active Harmony entirely, specify -DUSE_ACTIVEHARMONY=FALSE.  -DBUILD_ACTIVEHARMONY= \n  TRUE or  FALSE .  Whether or not Active Harmony is installed on the system, this option forces CMake to automatically download and build Active Harmony as part of the APEX project.  -DUSE_OMPT= \n  TRUE or  FALSE .  OMPT is a proposed standard for OpenMP runtimes to provide callback hooks to performance tools. For more information, see  http://openmp.org/mp-documents/ompt-tr2.pdf .  APEX has support for most OMPT OpenMP trace events. See  the OpenMP use case  for an example.  -DOMPT_ROOT= \n  the path to OMPT, or set the OMPT_ROOT environment variable before running cmake.  -DBUILD_OMPT= \n  TRUE or  FALSE . Whether or not an OpenMP library with OMPT support is found by CMake, this option forces CMake to automatically download and build an OpenMP runtime with OMPT support as part of the APEX project.  -DUSE_BFD= \n  TRUE or  FALSE .  APEX uses libbfd to convert instruction addresses to source code locations. BFD support is useful for generating human-readable output for summaries and concurrency graphs. Libbfd is not required for runtime adaptation.  -DBFD_ROOT= \n  path to Binutils, or set the BFD_ROOT environment variable.  -DBUILD_BFD= \n  TRUE or FALSE.  Whether or not binutils is found by CMake, this option forces CMake to automatically download and build binutils as part of the APEX project.  -DUSE_TAU= \n  TRUE or  FALSE .  TAU (Tuning and Analysis Utilities) is a performance measurement and analysis framework for large scale parallel applications. For more information see  http://tau.uoregon.edu .  APEX uses TAU to generate profiles for post-mortem performance analysis. See  the TAU use case  for an example.  -DTAU_ROOT= \n  path to TAU, or set the TAU_ROOT environment variable before running cmake.  -DTAU_ARCH= \n  the TAU architecture, like x86_64, craycnl, mic_linux, bgq, etc.  -DTAU_OPTIONS= \n  a TAU configuration with thread support, like -pthread or -icpc-pthread.  -DUSE_RCR= \n  TRUE or  FALSE .  RCR (Resource Centric Reflection) is a library for system monitoring of resources that require root access.  For more information, see  http://www.renci.org/wp-content/pub/techreports/TR-10-01.pdf .  APEX uses RCR to access 'uncore' counters and system health information such as power and energy counters.  -DRCR_ROOT= \n  the path to RCR, or set the RCR_ROOT environment variable.  -DUSE_TCMALLOC= \n  TRUE or  FALSE .  TCMalloc is a heap management library distributed as part of Google perftools. For more information, see  https://github.com/gperftools/gperftools .  TCMalloc provides faster memory performance in multithreaded environments.  -DGPERFTOOLS_ROOT= \n  path to gperftools (TCMalloc), or set the GPERFTOOLS_ROOT environment variable before running cmake.  -DUSE_JEMALLOC= \n  TRUE or  FALSE .  JEMalloc is a heap management library.  For more information, see  http://www.canonware.com/jemalloc/ .  JEMalloc provides faster memory performance in multithreaded environments.  -DJEMALLOC_ROOT= \n  path to JEMalloc, or set the JEMALLOC_ROOT environment variable before running cmake.  -DUSE_PAPI= \n  TRUE or  FALSE .  PAPI (Performance Application Programming Interface) provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors.  For more information, see  http://icl.cs.utk.edu/papi/ .  APEX uses PAPI to optionally collect hardware counters for timed events.  -DPAPI_ROOT= \n  some path to PAPI, or set the PAPI_ROOT environment variable before running cmake. See  the PAPI use case  for an example.  -DUSE_LM_SENSORS= \n  TRUE or  FALSE . Lm_sensors (Linux Monitoring Sensors) is a library for monitoring hardware temperatures and fan speeds. For more information, see  https://en.wikipedia.org/wiki/Lm_sensors .  APEX uses lm_sensors to monitor hardware, where available.  -DBUILD_EXAMPLES= \n  TRUE or  FALSE . Whether or not to build the application examples in APEX.  -DBUILD_TESTS= \n   TRUE  or FALSE. Whether or not to build the APEX unit tests.  -DCMAKE_C_COMPILER= \n   gcc  -DCMAKE_CXX_COMPILER= \n   g++  -DCMAKE_BUILD_TYPE= \n  Release,  Debug , RelWithDebInfo. Unfortunately, the cmake default (when not specified) is Debug. For faster performance, configure APEX to build RelWithDebInfo or Release.  -DBUILD_SHARED_LIBS= \n  TRUE or FALSE  -DUSE_MPI= \n  TRUE or  FALSE . Whether to build MPI global support and related examples.  -DMPI_C_INCLUDE_PATH= \n  path to MPI headers  -DMPI_CXX_INCLUDE_PATH= \n  path to MPI headers  -DMPI_C_LIBRARIES= \n  paths to MPI libraries, library names  -DMPI_CXX_LIBRARIES= \n  paths to MPI libraries, library names  -DMPI_C_COMPILER= \n  mpicc  -DMPI_CXX_COMPILER= \n  mpicxx", 
            "title": "Other CMake settings, depending on your needs/wants"
        }, 
        {
            "location": "/usage/", 
            "text": "Supported Runtime Systems\n\n\nHPX (Louisiana State University)\n\n\nHPX (High Performance ParalleX) is the original implementation of the ParalleX model. Developed and maintained by the Ste||ar Group at Louisiana State University, HPX is implemented in C++. For more information, see \nhttp://stellar.cct.lsu.edu/tag/hpx/\n.  For a tutorial on HPX with APEX (presented at SC'15, Austin TX) see \nhttps://github.com/khuck/SC15_APEX_tutorial\n.\n\n\nConfiguring HPX with APEX\n\n\n...Coming soon! For now, see \nhttps://github.com/khuck/SC15_APEX_tutorial\n.\n\n\nHPX-5 (Indiana University)\n\n\nHPX-5 (High Performance ParalleX) is a second implementation of the ParalleX model. Developed and maintained by the CREST Group at Indiana University, HPX-5 is implemented in C.  For more information, see \nhttps://hpx.crest.iu.edu\n.\n\n\nConfiguring HPX-5 with APEX\n\n\nAPEX is built as a pre-requisite dependency of HPX-5. So, before configuring and building HPX-5, configure and build APEX as a standalone library.  In addition to the usual required options for CMake, we will also include the options to include Active Harmony (for policies), TAU (for performance analysis - see \nAPEX with TAU\n for instructions on configuring TAU) and Binutils support, because the HPX-5 instrumentation uses function addresses to identify timers rather than strings.  To include Binutils, we can choose one of:\n\n\n\n\nuse a system-installed binutils by specifying \n-DUSE_BFD=TRUE\n\n\nuse a custom build of Binutils by specifying `-DUSE_BFD=TRUE -DBFD_ROOT=\n\n\nhave APEX download and build Binutils automatically by specifying \n-DBUILD_BFD=TRUE\n.\n\n\n\n\nNote:\n \nHPX-5 uses JEMalloc, TBB Malloc or DLMalloc, so \nDO NOT\n configure APEX with either TCMalloc or JEMalloc.\n\n\nFor example, assume Boost is installed in /usr/local/boost/1.54.0, TAU is installed in /usr/local/tau/2.25, and we will have CMake download and build Binutils and Active Harmony, and we want to install APEX to /usr/local/apex/0.1.  To configure, build and install APEX in the main source directory (your paths may vary):\n\n\ncd $HOME/src\nwget https://github.com/khuck/xpress-apex/archive/v0.1.tar.gz\ntar -xvzf v0.1.tar.gz\ncd xpress-apex-0.1\nmkdir build\ncd build\ncmake -DBOOST_ROOT=/usr/local/boost/1.54.0 \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_OPTIONS=-papi-pthread -DTAU_ARCH=x86_64 \\\n-DBUILD_BFD=TRUE -DCMAKE_INSTALL_PREFIX=/usr/local/xpress-apex/0.1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\nmake\nmake test # optional\nmake doc # optional\nmake install\n\n\n\n\nKeep in mind that APEX will automatically download, configure and build Active Harmony as part of the build process, unless you pass \n-DUSE_ACTIVEHARMONY=FALSE\n to the cmake command.  After the build is complete, add the package configuration path to your PKG_CONFIG_PATH environment variable (HPX-5 uses autotools for configuration so it will find APEX using the utility pkg-config):\n\n\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.1/lib/pkgconfig\n\n\n\n\nTo confirm the PKG_CONFIG_PATH variable is set correctly, try executing the pkg-config command:\n\n\npkg-config --libs apex\n\n\n\n\nWhich should give the following output (or something similar):\n\n\n-L/usr/local/xpress-apex/0.1/lib -L/usr/local/tau/2.25/x86_64/lib -L/usr/local/xpress-apex/0.1/lib -lapex -lboost_system -lboost_thread -lboost_timer -lboost_chrono -lboost_regex -lpthread -lTAUsh-papi-pthread -lharmony -lbfd -liberty -lz -lm -Wl,-rpath,/usr/local/xpress-apex/0.1/lib -Wl,-rpath,/usr/lib/x86_64-linux-gnu,-rpath,/usr/local/tau/2.25/x86_64/lib,-rpath,/usr/local/xpress-apex/0.1/lib -lstdc++\n\n\n\n\nOnce APEX is installed, you can configure and build HPX-5 with APEX.  To include APEX in the HPX-5 configuration, include the --with-apex=yes option when calling configure.  Assuming you have downloaded HPX-5 v.2.0, you would do the following:\n\n\n# go to the HPX source directory\ncd HPX_Release_v2.0.0/hpx\n# If you haven't already set the pkgconfig path, do so now...\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.1/lib/pkgconfig\n# configure\n./bootstrap\n./configure --enable-testsuite --prefix=/home/khuck/src/hpx-iu/hpx-install --with-apex=yes\n# build!\nmake -j8\n# install!\nmake install\n\n\n\n\nTo confirm that HPX-5 was configured and built with APEX correctly, run the simple APEX example:\n\n\nexport APEX_SCREEN_OUTPUT=1\n./tests/unit/apex\n\n\n\n\nWhich should give output similar to this:\n\n\nv0.1-5e4ac87-master\nBuilt on: 13:23:34 Dec 17 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n\nMissing fib number. Using 10.\nfib(10)=55\nseconds: 0.0005629\nlocalities: 1\nthreads/locality: 8\nInfo: 34 items remaining on on the profiler_listener queue...done.\nCPU is 2.66036e+09 Hz.\nElapsed time: 0.0364015\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 0.291212\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_fib_main_action [{/home/kh... :        1    --n/a--   4.52e-04    --n/a--   4.52e-04    --n/a--      0.155\n_fib_action [{/home/khuck/s... :      177    --n/a--   4.39e-06    --n/a--   7.77e-04    --n/a--      0.267\n_locality_stop_handler [{/h... :        1    --n/a--   1.21e-05    --n/a--   1.21e-05    --n/a--      0.004\n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   2.90e-01    --n/a--     99.574\n------------------------------------------------------------------------------------------------------------\n\n\n\n\nBuilding HPX-5 applications with APEX\n\n\nAPEX will automatically be included in the link when HPX-5 applciations are built. To build an example, go to the hpx-apps directory and build the LULESH parcels example:\n\n\ncd hpx-apps/lulesh/parcels\n# assuming HPX-5 is installed in /usr/local/hpx/2.0, set the pkgconfig path\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/hpx/2.0/lib/pkgconfig\n# configure \n./bootstrap\n./configure\n# make!\nmake\n\n\n\n\nThen, to run the LULESH example:\n\n\nexport APEX_SCREEN_OUTPUT=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8\n\n\n\n\nShould give the following output (or similar):\n\n\nv0.1-907c977-master\nBuilt on: 09:50:08 Dec 23 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n Number of domains: 8 nx: 24 maxcycles: 100 core-major ordering: 1\n\n\nSTART_LOG\nPROGNAME: lulesh-parcels\n\nElapsed time = 1.255209e+01\n\nRun completed:  \n  Problem size = 24 \n  Iteration count = 100 \n  Final Origin Energy = 4.739209e+06\n  Testing plane 0 of energy array:\n  MaxAbsDiff   = 9.313226e-10\n  TotalAbsDiff = 2.841568e-09\n  MaxRelDiff   = 2.946213e-12\n\nEND_LOG\n\ntime_in_SBN3 = 4.570989e-01\ntime_in_PosVel = 2.182410e-01\ntime_in_MonoQ = 4.889381e+00\n Elapsed: 12599.4\nCPU is 2.66028e+09 Hz.\nElapsed time: 12.6192\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 100.953\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_advanceDomain_action [{/ho... :        8    --n/a--   1.17e+01    --n/a--   9.34e+01    --n/a--     92.506\n_initDomain_action [{/home/... :        8    --n/a--   2.04e-02    --n/a--   1.63e-01    --n/a--      0.162\n_finiDomain_action [{/home/... :        8    --n/a--   2.81e-03    --n/a--   2.25e-02    --n/a--      0.022\n_main_action [{/home/khuck/... :        1    --n/a--   4.73e-03    --n/a--   4.73e-03    --n/a--      0.005\n_SBN1_result_action [{/home... :       56    --n/a--   1.42e-03    --n/a--   7.93e-02    --n/a--      0.079\n_SBN1_sends_action [{/home/... :       56    --n/a--   1.87e-04    --n/a--   1.05e-02    --n/a--      0.010\n_SBN3_result_action [{/home... :     5600    --n/a--   1.33e-04    --n/a--   7.45e-01    --n/a--      0.738\n_SBN3_sends_action [{/home/... :     5600    --n/a--   9.05e-05    --n/a--   5.07e-01    --n/a--      0.502\n_PosVel_result_action [{/ho... :     2800    --n/a--   1.61e-04    --n/a--   4.50e-01    --n/a--      0.445\n_PosVel_sends_action [{/hom... :     2800    --n/a--   1.43e-04    --n/a--   4.00e-01    --n/a--      0.396\n_MonoQ_result_action [{/hom... :     2400    --n/a--   1.03e-04    --n/a--   2.47e-01    --n/a--      0.245\n_MonoQ_sends_action [{/home... :     2400    --n/a--   1.79e-04    --n/a--   4.29e-01    --n/a--      0.425\n_locality_stop_handler [{/h... :        1    --n/a--   2.45e-04    --n/a--   2.45e-04    --n/a--      0.000\n_allreduce_init_handler [{/... :        2    --n/a--   5.49e-04    --n/a--   1.10e-03    --n/a--      0.001\n_allreduce_fini_handler [{/... :        2    --n/a--   2.44e-04    --n/a--   4.89e-04    --n/a--      0.000\n_allreduce_add_handler [{/h... :        9    --n/a--   6.74e-05    --n/a--   6.07e-04    --n/a--      0.001\n_allreduce_remove_handler [... :        9    --n/a--   4.31e-05    --n/a--   3.88e-04    --n/a--      0.000\n_allreduce_join_handler [{/... :       99    --n/a--   4.90e-05    --n/a--   4.86e-03    --n/a--      0.005\n_allreduce_bcast_handler [{... :       99    --n/a--   2.75e-05    --n/a--   2.72e-03    --n/a--      0.003\n                   CPU Guest % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                     CPU IRQ % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       12      0.000      0.789      8.429      9.464      2.305    --n/a-- \n                    CPU Nice % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       12     21.000     22.387     24.286    268.643      0.941    --n/a-- \n                    CPU User % :       12     77.500     80.426     89.714    965.107      4.315    --n/a-- \n                CPU soft IRQ % :       12      0.000      0.010      0.125      0.125      0.035    --n/a-- \n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   4.50e+00    --n/a--      4.455\n------------------------------------------------------------------------------------------------------------\n\n\n\n\nTo enable TAU profiling, set the APEX_TAU environment variable to 1.  We will also set some other TAU environment varaibles and re-run the program:\n\n\nexport APEX_TAU=1\nexport TAU_PROFILE_FORMAT=merged\nexport TAU_SAMPLING=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8\n\n\n\n\nThe \"merged\" profile setting will create a single file (tauprofile.xml) for the whole application, rather than a profile.* file for each thread. The sampling flag will enable periodic interruption of the application to get a more detailed profile.\n\n\nAfter execution, there is a TAU profile file called \"tauprofile.xml\".  To view the results of the profiling, run the ParaProf application on the profile (assuming the TAU utilities are in your path):\n\n\nparaprof tauprofile.xml\n\n\n\n\nWhich should result in a profile like the following:\n\n\n\n\nAbove: ParaProf main profiler window showing all threads of execution.\n\n\n\n\nAbove: ParaProf main profiler window showing one thread of execution.\n\n\n\n\nAbove: ParaProf main profiler window showing one thread of execution, in a callgraph view.\n\n\nFor more information on using TAU with APEX, see \nAPEX with TAU\n.\n\n\nOpenMP\n\n\nThe OpenMP API supports multi-platform shared-memory parallel programming in C/C++ and Fortran. The OpenMP API defines a portable, scalable model with a simple and flexible interface for developing parallel applications on platforms from the desktop to the supercomputer.  For more information, see \nhttp://openmp.org/\n.\n\n\nRunning OpenMP applications with APEX\n\n\n...Coming soon!", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#supported-runtime-systems", 
            "text": "", 
            "title": "Supported Runtime Systems"
        }, 
        {
            "location": "/usage/#hpx-louisiana-state-university", 
            "text": "HPX (High Performance ParalleX) is the original implementation of the ParalleX model. Developed and maintained by the Ste||ar Group at Louisiana State University, HPX is implemented in C++. For more information, see  http://stellar.cct.lsu.edu/tag/hpx/ .  For a tutorial on HPX with APEX (presented at SC'15, Austin TX) see  https://github.com/khuck/SC15_APEX_tutorial .  Configuring HPX with APEX  ...Coming soon! For now, see  https://github.com/khuck/SC15_APEX_tutorial .", 
            "title": "HPX (Louisiana State University)"
        }, 
        {
            "location": "/usage/#hpx-5-indiana-university", 
            "text": "HPX-5 (High Performance ParalleX) is a second implementation of the ParalleX model. Developed and maintained by the CREST Group at Indiana University, HPX-5 is implemented in C.  For more information, see  https://hpx.crest.iu.edu .  Configuring HPX-5 with APEX  APEX is built as a pre-requisite dependency of HPX-5. So, before configuring and building HPX-5, configure and build APEX as a standalone library.  In addition to the usual required options for CMake, we will also include the options to include Active Harmony (for policies), TAU (for performance analysis - see  APEX with TAU  for instructions on configuring TAU) and Binutils support, because the HPX-5 instrumentation uses function addresses to identify timers rather than strings.  To include Binutils, we can choose one of:   use a system-installed binutils by specifying  -DUSE_BFD=TRUE  use a custom build of Binutils by specifying `-DUSE_BFD=TRUE -DBFD_ROOT=  have APEX download and build Binutils automatically by specifying  -DBUILD_BFD=TRUE .   Note:   HPX-5 uses JEMalloc, TBB Malloc or DLMalloc, so  DO NOT  configure APEX with either TCMalloc or JEMalloc.  For example, assume Boost is installed in /usr/local/boost/1.54.0, TAU is installed in /usr/local/tau/2.25, and we will have CMake download and build Binutils and Active Harmony, and we want to install APEX to /usr/local/apex/0.1.  To configure, build and install APEX in the main source directory (your paths may vary):  cd $HOME/src\nwget https://github.com/khuck/xpress-apex/archive/v0.1.tar.gz\ntar -xvzf v0.1.tar.gz\ncd xpress-apex-0.1\nmkdir build\ncd build\ncmake -DBOOST_ROOT=/usr/local/boost/1.54.0 \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_OPTIONS=-papi-pthread -DTAU_ARCH=x86_64 \\\n-DBUILD_BFD=TRUE -DCMAKE_INSTALL_PREFIX=/usr/local/xpress-apex/0.1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\nmake\nmake test # optional\nmake doc # optional\nmake install  Keep in mind that APEX will automatically download, configure and build Active Harmony as part of the build process, unless you pass  -DUSE_ACTIVEHARMONY=FALSE  to the cmake command.  After the build is complete, add the package configuration path to your PKG_CONFIG_PATH environment variable (HPX-5 uses autotools for configuration so it will find APEX using the utility pkg-config):  export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.1/lib/pkgconfig  To confirm the PKG_CONFIG_PATH variable is set correctly, try executing the pkg-config command:  pkg-config --libs apex  Which should give the following output (or something similar):  -L/usr/local/xpress-apex/0.1/lib -L/usr/local/tau/2.25/x86_64/lib -L/usr/local/xpress-apex/0.1/lib -lapex -lboost_system -lboost_thread -lboost_timer -lboost_chrono -lboost_regex -lpthread -lTAUsh-papi-pthread -lharmony -lbfd -liberty -lz -lm -Wl,-rpath,/usr/local/xpress-apex/0.1/lib -Wl,-rpath,/usr/lib/x86_64-linux-gnu,-rpath,/usr/local/tau/2.25/x86_64/lib,-rpath,/usr/local/xpress-apex/0.1/lib -lstdc++  Once APEX is installed, you can configure and build HPX-5 with APEX.  To include APEX in the HPX-5 configuration, include the --with-apex=yes option when calling configure.  Assuming you have downloaded HPX-5 v.2.0, you would do the following:  # go to the HPX source directory\ncd HPX_Release_v2.0.0/hpx\n# If you haven't already set the pkgconfig path, do so now...\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.1/lib/pkgconfig\n# configure\n./bootstrap\n./configure --enable-testsuite --prefix=/home/khuck/src/hpx-iu/hpx-install --with-apex=yes\n# build!\nmake -j8\n# install!\nmake install  To confirm that HPX-5 was configured and built with APEX correctly, run the simple APEX example:  export APEX_SCREEN_OUTPUT=1\n./tests/unit/apex  Which should give output similar to this:  v0.1-5e4ac87-master\nBuilt on: 13:23:34 Dec 17 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n\nMissing fib number. Using 10.\nfib(10)=55\nseconds: 0.0005629\nlocalities: 1\nthreads/locality: 8\nInfo: 34 items remaining on on the profiler_listener queue...done.\nCPU is 2.66036e+09 Hz.\nElapsed time: 0.0364015\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 0.291212\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_fib_main_action [{/home/kh... :        1    --n/a--   4.52e-04    --n/a--   4.52e-04    --n/a--      0.155\n_fib_action [{/home/khuck/s... :      177    --n/a--   4.39e-06    --n/a--   7.77e-04    --n/a--      0.267\n_locality_stop_handler [{/h... :        1    --n/a--   1.21e-05    --n/a--   1.21e-05    --n/a--      0.004\n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   2.90e-01    --n/a--     99.574\n------------------------------------------------------------------------------------------------------------  Building HPX-5 applications with APEX  APEX will automatically be included in the link when HPX-5 applciations are built. To build an example, go to the hpx-apps directory and build the LULESH parcels example:  cd hpx-apps/lulesh/parcels\n# assuming HPX-5 is installed in /usr/local/hpx/2.0, set the pkgconfig path\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/hpx/2.0/lib/pkgconfig\n# configure \n./bootstrap\n./configure\n# make!\nmake  Then, to run the LULESH example:  export APEX_SCREEN_OUTPUT=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8  Should give the following output (or similar):  v0.1-907c977-master\nBuilt on: 09:50:08 Dec 23 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n Number of domains: 8 nx: 24 maxcycles: 100 core-major ordering: 1\n\n\nSTART_LOG\nPROGNAME: lulesh-parcels\n\nElapsed time = 1.255209e+01\n\nRun completed:  \n  Problem size = 24 \n  Iteration count = 100 \n  Final Origin Energy = 4.739209e+06\n  Testing plane 0 of energy array:\n  MaxAbsDiff   = 9.313226e-10\n  TotalAbsDiff = 2.841568e-09\n  MaxRelDiff   = 2.946213e-12\n\nEND_LOG\n\ntime_in_SBN3 = 4.570989e-01\ntime_in_PosVel = 2.182410e-01\ntime_in_MonoQ = 4.889381e+00\n Elapsed: 12599.4\nCPU is 2.66028e+09 Hz.\nElapsed time: 12.6192\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 100.953\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_advanceDomain_action [{/ho... :        8    --n/a--   1.17e+01    --n/a--   9.34e+01    --n/a--     92.506\n_initDomain_action [{/home/... :        8    --n/a--   2.04e-02    --n/a--   1.63e-01    --n/a--      0.162\n_finiDomain_action [{/home/... :        8    --n/a--   2.81e-03    --n/a--   2.25e-02    --n/a--      0.022\n_main_action [{/home/khuck/... :        1    --n/a--   4.73e-03    --n/a--   4.73e-03    --n/a--      0.005\n_SBN1_result_action [{/home... :       56    --n/a--   1.42e-03    --n/a--   7.93e-02    --n/a--      0.079\n_SBN1_sends_action [{/home/... :       56    --n/a--   1.87e-04    --n/a--   1.05e-02    --n/a--      0.010\n_SBN3_result_action [{/home... :     5600    --n/a--   1.33e-04    --n/a--   7.45e-01    --n/a--      0.738\n_SBN3_sends_action [{/home/... :     5600    --n/a--   9.05e-05    --n/a--   5.07e-01    --n/a--      0.502\n_PosVel_result_action [{/ho... :     2800    --n/a--   1.61e-04    --n/a--   4.50e-01    --n/a--      0.445\n_PosVel_sends_action [{/hom... :     2800    --n/a--   1.43e-04    --n/a--   4.00e-01    --n/a--      0.396\n_MonoQ_result_action [{/hom... :     2400    --n/a--   1.03e-04    --n/a--   2.47e-01    --n/a--      0.245\n_MonoQ_sends_action [{/home... :     2400    --n/a--   1.79e-04    --n/a--   4.29e-01    --n/a--      0.425\n_locality_stop_handler [{/h... :        1    --n/a--   2.45e-04    --n/a--   2.45e-04    --n/a--      0.000\n_allreduce_init_handler [{/... :        2    --n/a--   5.49e-04    --n/a--   1.10e-03    --n/a--      0.001\n_allreduce_fini_handler [{/... :        2    --n/a--   2.44e-04    --n/a--   4.89e-04    --n/a--      0.000\n_allreduce_add_handler [{/h... :        9    --n/a--   6.74e-05    --n/a--   6.07e-04    --n/a--      0.001\n_allreduce_remove_handler [... :        9    --n/a--   4.31e-05    --n/a--   3.88e-04    --n/a--      0.000\n_allreduce_join_handler [{/... :       99    --n/a--   4.90e-05    --n/a--   4.86e-03    --n/a--      0.005\n_allreduce_bcast_handler [{... :       99    --n/a--   2.75e-05    --n/a--   2.72e-03    --n/a--      0.003\n                   CPU Guest % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                     CPU IRQ % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       12      0.000      0.789      8.429      9.464      2.305    --n/a-- \n                    CPU Nice % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       12     21.000     22.387     24.286    268.643      0.941    --n/a-- \n                    CPU User % :       12     77.500     80.426     89.714    965.107      4.315    --n/a-- \n                CPU soft IRQ % :       12      0.000      0.010      0.125      0.125      0.035    --n/a-- \n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   4.50e+00    --n/a--      4.455\n------------------------------------------------------------------------------------------------------------  To enable TAU profiling, set the APEX_TAU environment variable to 1.  We will also set some other TAU environment varaibles and re-run the program:  export APEX_TAU=1\nexport TAU_PROFILE_FORMAT=merged\nexport TAU_SAMPLING=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8  The \"merged\" profile setting will create a single file (tauprofile.xml) for the whole application, rather than a profile.* file for each thread. The sampling flag will enable periodic interruption of the application to get a more detailed profile.  After execution, there is a TAU profile file called \"tauprofile.xml\".  To view the results of the profiling, run the ParaProf application on the profile (assuming the TAU utilities are in your path):  paraprof tauprofile.xml  Which should result in a profile like the following:   Above: ParaProf main profiler window showing all threads of execution.   Above: ParaProf main profiler window showing one thread of execution.   Above: ParaProf main profiler window showing one thread of execution, in a callgraph view.  For more information on using TAU with APEX, see  APEX with TAU .", 
            "title": "HPX-5 (Indiana University)"
        }, 
        {
            "location": "/usage/#openmp", 
            "text": "The OpenMP API supports multi-platform shared-memory parallel programming in C/C++ and Fortran. The OpenMP API defines a portable, scalable model with a simple and flexible interface for developing parallel applications on platforms from the desktop to the supercomputer.  For more information, see  http://openmp.org/ .  Running OpenMP applications with APEX  ...Coming soon!", 
            "title": "OpenMP"
        }, 
        {
            "location": "/usecases/", 
            "text": "Before you start\n\n\nAll examples on this page assume you have downloaded, configured and built APEX.  \nSee the Getting Started page\n for instructions on how to do that.\n\n\nSimple example\n\n\nIn the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is a simple matrix multiplication example, \nmatmult\n. \n\n\nTo run the matmult example, simply type 'matmult'.  The output should be something like this:\n\n\nkhuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\n\n\n\n\nNot very interesting, eh? To see what APEX measured, set the APEX_SCREEN_OUTPUT environment variable to 1, and run it again:\n\n\nkhuck@ktau:~/src/xpress-apex/install/bin$ export APEX_SCREEN_OUTPUT=1\nkhuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66013e+09 Hz.\nElapsed time: 0.966516\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.86607\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   1.94e-02    --n/a--   2.33e-01    --n/a--      6.014\n                       compute :        4    --n/a--   6.89e-01    --n/a--   2.76e+00    --n/a--     71.279\n           compute_interchange :        4    --n/a--   1.85e-01    --n/a--   7.38e-01    --n/a--     19.091\n                       do_work :        4    --n/a--   9.43e-01    --n/a--   3.77e+00    --n/a--     97.601\n                    freeMatrix :       12    --n/a--   2.36e-04    --n/a--   2.83e-03    --n/a--      0.073\n                    initialize :       12    --n/a--   3.56e-03    --n/a--   4.27e-02    --n/a--      1.104\n                          main :        1    --n/a--   9.66e-01    --n/a--   9.66e-01    --n/a--     24.983\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------\n\n\n\n\nIn this output, we see the status of all of the environment variables (as read by APEX at initialization), the regular program output, and then a summary from APEX at the end. Because APEX captures timestamps using the low-overhead rdtsc function call (where available), the measurements are done in cycles. APEX estimates the Hz rating of the CPU to convert to seconds for output. APEX reports the elapsed wall-clock time, the number of cores detected, the number of worker threads observed, as well as the total available CPU time (wall-clock times workers).\n\n\nOpenMP example\n\n\nIn the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is the OpenMP implementation of LULESH (for details, \nsee the LLNL explanation of LULESH\n).  When APEX is configured with OpenMP OMPT support (using the -DBUILD_OMPT=TRUE or equivalent CMake configuration settings) it will measure OpenMP events. Executing the LULESH example (with APEX_SCREEN_OUTPUT=1) gives the following output:\n\n\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/lulesh_OpenMP_2.0 \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nRunning problem size 30^3 per domain until completion\nNum processors: 1\nRegistering OMPT events...done.\nNum threads: 8\nTotal number of elements: 27000\n\nTo run other sizes, use -s \ninteger\n.\nTo run a fixed number of iterations, use -i \ninteger\n.\nTo run a more or less balanced region set, use -b \ninteger\n.\nTo change the relative costs of regions, use -c \ninteger\n.\nTo print out progress, use -p\nTo write an output file for VisIt, use -v\nSee help (-h) for more options\n\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcCourant...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcHydroCo...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcMonoton...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcSoundSp...\nAPEX: disabling lightweight timer OpenMP_BARRIER: InitStressT...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVolumeF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcAcceler...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVelocit...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPositio...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcLagrang...\nAPEX: disabling lightweight timer OpenMP_BARRIER: UpdateVolum...\nAPEX: disabling lightweight timer OpenMP_BARRIER: ApplyAccele...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcForceFo...\nRun completed:  \n   Problem size        =  30 \n   MPI tasks           =  1 \n   Iteration count     =  932 \n   Final Origin Energy = 2.025075e+05 \n   Testing Plane 0 of Energy Array on rank 0:\n        MaxAbsDiff   = 6.548362e-11\n        TotalAbsDiff = 8.615093e-10\n        MaxRelDiff   = 1.461140e-12\n\n\nElapsed time         =      55.00 (s)\nGrind time (us/z/c)  =  2.1855548 (per dom)  ( 2.1855548 overall)\nFOM                  =  457.54973 (z/s)\n\nCPU is 2.66013e+09 Hz.\nElapsed time: 55.0085\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 440.068\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                   CPU Guest % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       54      0.000      0.040      0.714      2.143      0.133    --n/a-- \n                     CPU IRQ % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       54      0.857      1.384      4.857     74.714      0.763    --n/a-- \n                    CPU Nice % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       54     15.286     23.339     26.714   1260.286      2.301    --n/a-- \n                    CPU User % :       54     84.143     88.373     97.143   4772.143      2.268    --n/a-- \n                CPU soft IRQ % :       54      0.000      0.026      0.286      1.429      0.068    --n/a-- \nOpenMP_BARRIER: ApplyAccele... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: ApplyMateri... :    14912    --n/a--   3.96e-05    --n/a--   5.91e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcAcceler... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcCourant... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.11e-04    --n/a--   8.27e-01    --n/a--      0.188\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.49e-04    --n/a--   1.11e+00    --n/a--      0.252\nOpenMP_BARRIER: CalcForceFo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcHourgla... :     7456    --n/a--   1.32e-04    --n/a--   9.84e-01    --n/a--      0.224\nOpenMP_BARRIER: CalcHydroCo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcKinemat... :     7456    --n/a--   7.88e-05    --n/a--   5.88e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcLagrang... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcMonoton... :     7456    --n/a--   6.98e-05    --n/a--   5.21e-01    --n/a--      0.118\nOpenMP_BARRIER: CalcMonoton... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPositio... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcSoundSp... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVelocit... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVolumeF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: InitStressT... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   6.66e-05    --n/a--   4.97e-01    --n/a--      0.113\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   1.28e-04    --n/a--   9.54e-01    --n/a--      0.217\nOpenMP_BARRIER: UpdateVolum... : DISABLED (high frequency, short duration)\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   1.09e-04    --n/a--   1.01e-01    --n/a--      0.023\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   2.58e-04    --n/a--   2.40e-01    --n/a--      0.055\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   7.83e-04    --n/a--   7.30e-01    --n/a--      0.166\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   7.72e-05    --n/a--   7.91e-01    --n/a--      0.180\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.29e-05    --n/a--   1.40e+00    --n/a--      0.318\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   5.07e-05    --n/a--   1.65e+00    --n/a--      0.376\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   3.31e-05    --n/a--   1.08e+00    --n/a--      0.245\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.75e-05    --n/a--   1.55e+00    --n/a--      0.352\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.09e-05    --n/a--   1.34e+00    --n/a--      0.303\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   8.10e-03    --n/a--   7.55e+00    --n/a--      1.715\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.51e-03    --n/a--   3.28e+00    --n/a--      0.744\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.34e-04    --n/a--   4.05e-01    --n/a--      0.092\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.27e-03    --n/a--   3.98e+00    --n/a--      0.905\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.72e-05    --n/a--   4.84e-01    --n/a--      0.110\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.68e-03    --n/a--   1.57e+00    --n/a--      0.356\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   2.29e-04    --n/a--   2.13e-01    --n/a--      0.048\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.15e-03    --n/a--   1.07e+00    --n/a--      0.244\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   2.29e-04    --n/a--   2.34e+00    --n/a--      0.533\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.98e-04    --n/a--   4.64e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.26e-05    --n/a--   3.19e+00    --n/a--      0.725\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.20e-05    --n/a--   3.13e+00    --n/a--      0.712\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.52e-05    --n/a--   4.63e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.39e-04    --n/a--   3.16e-01    --n/a--      0.072\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.57e-04    --n/a--   1.47e-01    --n/a--      0.033\nOpenMP_PARALLEL_REGION: Eva... :    32620    --n/a--   1.07e-04    --n/a--   3.50e+00    --n/a--      0.796\nOpenMP_PARALLEL_REGION: Eva... :    10252    --n/a--   2.86e-05    --n/a--   2.93e-01    --n/a--      0.067\nOpenMP_PARALLEL_REGION: Ini... :      932    --n/a--   3.52e-04    --n/a--   3.28e-01    --n/a--      0.074\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   3.14e-03    --n/a--   2.93e+00    --n/a--      0.666\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   2.18e-03    --n/a--   2.03e+00    --n/a--      0.461\nOpenMP_PARALLEL_REGION: Upd... :      932    --n/a--   1.34e-04    --n/a--   1.25e-01    --n/a--      0.028\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   3.87e+02    --n/a--     88.011\n------------------------------------------------------------------------------------------------------------\n\n\n\n\nThere are several lightweight events that APEX elects to ignore. The other events are timed by APEX and reported at exit, along with the /proc/stat data (CPU % counters).\n\n\nWith PAPI\n\n\nWhen APEX is configured with PAPI support (using -DPAPI_ROOT=/path/to/papi and -DUSE_PAPI=TRUE), hardware counter data can also be collected by APEX. To specify hardware counters of interest, use the APEX_PAPI_METRICS environment variable:\n\n\nkhuck@ktau:~/src/xpress-apex$ export APEX_PAPI_METRICS=\nPAPI_TOT_INS PAPI_L2_TCM\n\n\n\n\n\n...and then execute as normal:\n\n\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 1\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : PAPI_TOT_INS PAPI_L2_TCM\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66019e+09 Hz.\nElapsed time: 0.954974\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.81989\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  PAPI_TOT_INS PAPI_L2_TCM\n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   2.21e-02    --n/a--   2.65e-01    --n/a--      6.930   1.62e+06   9.10e+03\n                       compute :        4    --n/a--   6.85e-01    --n/a--   2.74e+00    --n/a--     71.743   4.31e+09   1.71e+06\n           compute_interchange :        4    --n/a--   1.81e-01    --n/a--   7.23e-01    --n/a--     18.922   3.77e+09   8.12e+05\n                       do_work :        4    --n/a--   9.44e-01    --n/a--   3.78e+00    --n/a--     98.851   8.10e+09   2.92e+06\n                    freeMatrix :       12    --n/a--   2.07e-04    --n/a--   2.49e-03    --n/a--      0.065   1.13e+06   6.30e+03\n                    initialize :       12    --n/a--   3.58e-03    --n/a--   4.29e-02    --n/a--      1.124   2.21e+07   3.80e+05\n                          main :        1    --n/a--   9.54e-01    --n/a--   9.54e-01    --n/a--     24.978   2.03e+09   7.66e+05\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------\n\n\n\n\nCSV output\n\n\nWhile APEX is not designed for post-mortem performance analysis, you can export the data that APEX collected.  If you set the APEX_CSV_OUTPUT environment variable to 1, APEX will also dump the timer statistics as a CSV file:\n\n\nkhuck@ktau:~/src/xpress-apex$ cat apex.0.csv \n\ntask\n,\nnum calls\n,\ntotal cycles\n,\ntotal microseconds\n,\nPAPI_TOT_INS\n,\nPAPI_L2_TCM\n\n\nallocateMatrix\n,12,704195504,264717,1615804,9100\n\ncompute\n,4,7290209200,2740489,4306522734,1709040\n\ncompute_interchange\n,4,1922797744,722806,3769652571,812196\n\ndo_work\n,4,10044907856,3776018,8101109302,2922142\n\nfreeMatrix\n,12,6613336,2486,1132717,6301\n\ninitialize\n,12,114177592,42921,22093639,379785\n\nmain\n,1,2538202992,954145,2025172707,766218\n\n\n\n\nWith TAU\n\n\nIf APEX is configured with TAU support, then APEX measurements will be forwarded to TAU and recorded as a TAU profile.  In addition, all other TAU features are supported, including sampling, MPI measurement, I/O measurement, tracing, etc. To configure APEX with TAU, specify the flags -DUSE_TAU, -DTAU_ROOT, -DTAU_ARCH, and -DTAU_OPTIONS. For example, if TAU was configured with \"./configure -pthread\" on an x86_64 Linux machine, the APEX configuration options would be \"-DUSE_TAU=1 -DTAU_ROOT=/path/to/tau -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-pthread\".\n\n\nHere is a suggested configuration for TAU on x86-Linux to use with APEX (some systems require special flags - please contact the maintaners if you are interested):\n\n\n# download the latest TAU release\nwget http://www.cs.uoregon.edu/research/paracomp/tau/tauprofile/dist/tau_latest.tar.gz\n# expand the tar file\ntar -xvzf tau_latest.tar.gz\ncd tau-2.25\n# configure TAU\n./configure -papi=/usr/local/papi/5.3.2 -pthread -prefix=/usr/local/tau/2.25\n# build\nmake -j install\n# set our path to include the new TAU installation\nexport PATH=$PATH:/usr/local/tau/2.25/x86_64/bin\n\n\n\n\nHere is a suggested configuration for APEX to use the above TAU installation:\n\n\ncd xpress-apex\nmkdir build-tau\ncd build-tau\ncmake -DBUILD_EXAMPLES=TRUE -DBUILD_TESTS=TRUE -DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-papi-pthread \\\n-DBUILD_BFD=TRUE -DBUILD_ACTIVEHARMONY=TRUE -DCMAKE_INSTALL_PREFIX=../install-tau ..\nmake\nmake tests\nmake install\n\n\n\n\nAfter configuring, building and installing TAU and then configuring, building and installing APEX, the TAU profiling is enabled by setting the environment variable \"APEX_TAU=1\".  After executing an example (say 'matmult'), there should be profile.* files in the working directory:\n\n\nkhuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls profile.*\nprofile.0.0.0  profile.0.0.1  profile.0.0.2  profile.0.0.3  profile.0.0.4  profile.0.0.5\n\n\n\n\nIf the TAU analysis utilties are in your path, you can execute \nparaprof\n to view the profiles:\n\n\nkhuck@ktau:~/src/xpress-apex$ paraprof\n\n\n\n\n...which should launch the ParaProf profile viewer/analysis program. The profile should look something like the following (for a complete manual on using ParaProf, see \nthe TAU website\n).\n\n\n\n\n\n\nIf you want to collect a TAU trace, you would enable the appropriate TAU environment variable (TAU_TRACE=1), and then re-run the example.  After the execution, the trace files need to be merged (using tau_treemerge.pl) and then converted (with tau2slog2) to be viewed with the Jumpshot trace viewer (included with TAU):\n\n\nkhuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ export TAU_TRACE=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls *.edf *.trc\nevents.0.edf        tautrace.0.0.1.trc  tautrace.0.0.3.trc  tautrace.0.0.5.trc\ntautrace.0.0.0.trc  tautrace.0.0.2.trc  tautrace.0.0.4.trc\n\n# merge the trace\nkhuck@ktau:~/src/xpress-apex$ tau_treemerge.pl \n/home/khuck/src/tau2/x86_64/bin/tau_merge -m tau.edf -e events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf tautrace.0.0.0.trc tautrace.0.0.1.trc tautrace.0.0.2.trc tautrace.0.0.3.trc tautrace.0.0.4.trc tautrace.0.0.5.trc tau.trc\ntautrace.0.0.0.trc: 34 records read.\ntautrace.0.0.1.trc: 8 records read.\ntautrace.0.0.2.trc: 8 records read.\ntautrace.0.0.3.trc: 30 records read.\ntautrace.0.0.4.trc: 30 records read.\ntautrace.0.0.5.trc: 30 records read.\n\n# convert the trace\nkhuck@ktau:~/src/xpress-apex$ tau2slog2 tau.trc tau.edf -o tau.slog2\n140 records initialized.  Processing.\n2 Records read. 1% converted\n4 Records read. 2% converted\n6 Records read. 4% converted\n8 Records read. 5% converted\n10 Records read. 7% converted\n12 Records read. 8% converted\n14 Records read. 10% converted\n16 Records read. 11% converted\n18 Records read. 12% converted\n20 Records read. 14% converted\n22 Records read. 15% converted\n24 Records read. 17% converted\n26 Records read. 18% converted\n28 Records read. 20% converted\n30 Records read. 21% converted\n32 Records read. 22% converted\n34 Records read. 24% converted\n36 Records read. 25% converted\n38 Records read. 27% converted\n40 Records read. 28% converted\n42 Records read. 30% converted\n44 Records read. 31% converted\n46 Records read. 32% converted\n48 Records read. 34% converted\n50 Records read. 35% converted\n52 Records read. 37% converted\n54 Records read. 38% converted\n56 Records read. 40% converted\n58 Records read. 41% converted\n60 Records read. 42% converted\n62 Records read. 44% converted\n64 Records read. 45% converted\n66 Records read. 47% converted\n68 Records read. 48% converted\n70 Records read. 50% converted\n72 Records read. 51% converted\n74 Records read. 52% converted\n76 Records read. 54% converted\n78 Records read. 55% converted\n80 Records read. 57% converted\n82 Records read. 58% converted\n84 Records read. 60% converted\n86 Records read. 61% converted\n88 Records read. 62% converted\n90 Records read. 64% converted\n92 Records read. 65% converted\n94 Records read. 67% converted\n96 Records read. 68% converted\n98 Records read. 70% converted\n100 Records read. 71% converted\n102 Records read. 72% converted\n104 Records read. 74% converted\n106 Records read. 75% converted\n108 Records read. 77% converted\n110 Records read. 78% converted\n112 Records read. 80% converted\n114 Records read. 81% converted\n116 Records read. 82% converted\n118 Records read. 84% converted\n120 Records read. 85% converted\n122 Records read. 87% converted\n124 Records read. 88% converted\n1521 enters: 0 exits: 0\n126 Records read. 90% converted\n1521 enters: 0 exits: 0\n128 Records read. 91% converted\n130 Records read. 92% converted\n1521 enters: 0 exits: 0\n132 Records read. 94% converted\n1521 enters: 0 exits: 0\n134 Records read. 95% converted\n136 Records read. 97% converted\n1521 enters: 0 exits: 0\n138 Records read. 98% converted\n1521 enters: 0 exits: 0\n140 Records read. 100% converted\nReached end of trace file.\nGetting YMap, Maxnode: 0, Maxthread: 5\n     SLOG-2 Header:\nversion = SLOG 2.0.6\nNumOfChildrenPerNode = 2\nTreeLeafByteSize = 65536\nMaxTreeDepth = 0\nMaxBufferByteSize = 1960\nCategories  is FBinfo(641 @ 2068)\nMethodDefs  is FBinfo(0 @ 0)\nLineIDMaps  is FBinfo(197 @ 2709)\nTreeRoot    is FBinfo(1960 @ 108)\nTreeDir     is FBinfo(38 @ 2906)\nAnnotations is FBinfo(0 @ 0)\nPostamble   is FBinfo(0 @ 0)\n\n1521 enters: 0 exits: 0\n\nNumber of Drawables = 58\ntimeElapsed between 1 \n 2 = 67 msec\ntimeElapsed between 2 \n 3 = 28 msec\n\n# open jumpshot\nkhuck@ktau:~/src/xpress-apex$ jumpshot tau.slog2\n\n\n\n\n\n\n\n\nPolicy Rules and Runtime Adaptation\n\n\n...Coming soon!", 
            "title": "Use Cases"
        }, 
        {
            "location": "/usecases/#before-you-start", 
            "text": "All examples on this page assume you have downloaded, configured and built APEX.   See the Getting Started page  for instructions on how to do that.", 
            "title": "Before you start"
        }, 
        {
            "location": "/usecases/#simple-example", 
            "text": "In the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is a simple matrix multiplication example,  matmult .   To run the matmult example, simply type 'matmult'.  The output should be something like this:  khuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.  Not very interesting, eh? To see what APEX measured, set the APEX_SCREEN_OUTPUT environment variable to 1, and run it again:  khuck@ktau:~/src/xpress-apex/install/bin$ export APEX_SCREEN_OUTPUT=1\nkhuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66013e+09 Hz.\nElapsed time: 0.966516\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.86607\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   1.94e-02    --n/a--   2.33e-01    --n/a--      6.014\n                       compute :        4    --n/a--   6.89e-01    --n/a--   2.76e+00    --n/a--     71.279\n           compute_interchange :        4    --n/a--   1.85e-01    --n/a--   7.38e-01    --n/a--     19.091\n                       do_work :        4    --n/a--   9.43e-01    --n/a--   3.77e+00    --n/a--     97.601\n                    freeMatrix :       12    --n/a--   2.36e-04    --n/a--   2.83e-03    --n/a--      0.073\n                    initialize :       12    --n/a--   3.56e-03    --n/a--   4.27e-02    --n/a--      1.104\n                          main :        1    --n/a--   9.66e-01    --n/a--   9.66e-01    --n/a--     24.983\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------  In this output, we see the status of all of the environment variables (as read by APEX at initialization), the regular program output, and then a summary from APEX at the end. Because APEX captures timestamps using the low-overhead rdtsc function call (where available), the measurements are done in cycles. APEX estimates the Hz rating of the CPU to convert to seconds for output. APEX reports the elapsed wall-clock time, the number of cores detected, the number of worker threads observed, as well as the total available CPU time (wall-clock times workers).", 
            "title": "Simple example"
        }, 
        {
            "location": "/usecases/#openmp-example", 
            "text": "In the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is the OpenMP implementation of LULESH (for details,  see the LLNL explanation of LULESH ).  When APEX is configured with OpenMP OMPT support (using the -DBUILD_OMPT=TRUE or equivalent CMake configuration settings) it will measure OpenMP events. Executing the LULESH example (with APEX_SCREEN_OUTPUT=1) gives the following output:  khuck@ktau:~/src/xpress-apex$ ./install/bin/lulesh_OpenMP_2.0 \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nRunning problem size 30^3 per domain until completion\nNum processors: 1\nRegistering OMPT events...done.\nNum threads: 8\nTotal number of elements: 27000\n\nTo run other sizes, use -s  integer .\nTo run a fixed number of iterations, use -i  integer .\nTo run a more or less balanced region set, use -b  integer .\nTo change the relative costs of regions, use -c  integer .\nTo print out progress, use -p\nTo write an output file for VisIt, use -v\nSee help (-h) for more options\n\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcCourant...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcHydroCo...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcMonoton...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcSoundSp...\nAPEX: disabling lightweight timer OpenMP_BARRIER: InitStressT...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVolumeF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcAcceler...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVelocit...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPositio...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcLagrang...\nAPEX: disabling lightweight timer OpenMP_BARRIER: UpdateVolum...\nAPEX: disabling lightweight timer OpenMP_BARRIER: ApplyAccele...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcForceFo...\nRun completed:  \n   Problem size        =  30 \n   MPI tasks           =  1 \n   Iteration count     =  932 \n   Final Origin Energy = 2.025075e+05 \n   Testing Plane 0 of Energy Array on rank 0:\n        MaxAbsDiff   = 6.548362e-11\n        TotalAbsDiff = 8.615093e-10\n        MaxRelDiff   = 1.461140e-12\n\n\nElapsed time         =      55.00 (s)\nGrind time (us/z/c)  =  2.1855548 (per dom)  ( 2.1855548 overall)\nFOM                  =  457.54973 (z/s)\n\nCPU is 2.66013e+09 Hz.\nElapsed time: 55.0085\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 440.068\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                   CPU Guest % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       54      0.000      0.040      0.714      2.143      0.133    --n/a-- \n                     CPU IRQ % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       54      0.857      1.384      4.857     74.714      0.763    --n/a-- \n                    CPU Nice % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       54     15.286     23.339     26.714   1260.286      2.301    --n/a-- \n                    CPU User % :       54     84.143     88.373     97.143   4772.143      2.268    --n/a-- \n                CPU soft IRQ % :       54      0.000      0.026      0.286      1.429      0.068    --n/a-- \nOpenMP_BARRIER: ApplyAccele... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: ApplyMateri... :    14912    --n/a--   3.96e-05    --n/a--   5.91e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcAcceler... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcCourant... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.11e-04    --n/a--   8.27e-01    --n/a--      0.188\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.49e-04    --n/a--   1.11e+00    --n/a--      0.252\nOpenMP_BARRIER: CalcForceFo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcHourgla... :     7456    --n/a--   1.32e-04    --n/a--   9.84e-01    --n/a--      0.224\nOpenMP_BARRIER: CalcHydroCo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcKinemat... :     7456    --n/a--   7.88e-05    --n/a--   5.88e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcLagrang... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcMonoton... :     7456    --n/a--   6.98e-05    --n/a--   5.21e-01    --n/a--      0.118\nOpenMP_BARRIER: CalcMonoton... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPositio... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcSoundSp... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVelocit... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVolumeF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: InitStressT... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   6.66e-05    --n/a--   4.97e-01    --n/a--      0.113\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   1.28e-04    --n/a--   9.54e-01    --n/a--      0.217\nOpenMP_BARRIER: UpdateVolum... : DISABLED (high frequency, short duration)\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   1.09e-04    --n/a--   1.01e-01    --n/a--      0.023\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   2.58e-04    --n/a--   2.40e-01    --n/a--      0.055\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   7.83e-04    --n/a--   7.30e-01    --n/a--      0.166\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   7.72e-05    --n/a--   7.91e-01    --n/a--      0.180\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.29e-05    --n/a--   1.40e+00    --n/a--      0.318\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   5.07e-05    --n/a--   1.65e+00    --n/a--      0.376\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   3.31e-05    --n/a--   1.08e+00    --n/a--      0.245\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.75e-05    --n/a--   1.55e+00    --n/a--      0.352\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.09e-05    --n/a--   1.34e+00    --n/a--      0.303\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   8.10e-03    --n/a--   7.55e+00    --n/a--      1.715\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.51e-03    --n/a--   3.28e+00    --n/a--      0.744\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.34e-04    --n/a--   4.05e-01    --n/a--      0.092\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.27e-03    --n/a--   3.98e+00    --n/a--      0.905\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.72e-05    --n/a--   4.84e-01    --n/a--      0.110\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.68e-03    --n/a--   1.57e+00    --n/a--      0.356\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   2.29e-04    --n/a--   2.13e-01    --n/a--      0.048\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.15e-03    --n/a--   1.07e+00    --n/a--      0.244\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   2.29e-04    --n/a--   2.34e+00    --n/a--      0.533\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.98e-04    --n/a--   4.64e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.26e-05    --n/a--   3.19e+00    --n/a--      0.725\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.20e-05    --n/a--   3.13e+00    --n/a--      0.712\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.52e-05    --n/a--   4.63e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.39e-04    --n/a--   3.16e-01    --n/a--      0.072\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.57e-04    --n/a--   1.47e-01    --n/a--      0.033\nOpenMP_PARALLEL_REGION: Eva... :    32620    --n/a--   1.07e-04    --n/a--   3.50e+00    --n/a--      0.796\nOpenMP_PARALLEL_REGION: Eva... :    10252    --n/a--   2.86e-05    --n/a--   2.93e-01    --n/a--      0.067\nOpenMP_PARALLEL_REGION: Ini... :      932    --n/a--   3.52e-04    --n/a--   3.28e-01    --n/a--      0.074\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   3.14e-03    --n/a--   2.93e+00    --n/a--      0.666\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   2.18e-03    --n/a--   2.03e+00    --n/a--      0.461\nOpenMP_PARALLEL_REGION: Upd... :      932    --n/a--   1.34e-04    --n/a--   1.25e-01    --n/a--      0.028\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   3.87e+02    --n/a--     88.011\n------------------------------------------------------------------------------------------------------------  There are several lightweight events that APEX elects to ignore. The other events are timed by APEX and reported at exit, along with the /proc/stat data (CPU % counters).", 
            "title": "OpenMP example"
        }, 
        {
            "location": "/usecases/#with-papi", 
            "text": "When APEX is configured with PAPI support (using -DPAPI_ROOT=/path/to/papi and -DUSE_PAPI=TRUE), hardware counter data can also be collected by APEX. To specify hardware counters of interest, use the APEX_PAPI_METRICS environment variable:  khuck@ktau:~/src/xpress-apex$ export APEX_PAPI_METRICS= PAPI_TOT_INS PAPI_L2_TCM   ...and then execute as normal:  khuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 1\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : PAPI_TOT_INS PAPI_L2_TCM\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66019e+09 Hz.\nElapsed time: 0.954974\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.81989\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  PAPI_TOT_INS PAPI_L2_TCM\n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   2.21e-02    --n/a--   2.65e-01    --n/a--      6.930   1.62e+06   9.10e+03\n                       compute :        4    --n/a--   6.85e-01    --n/a--   2.74e+00    --n/a--     71.743   4.31e+09   1.71e+06\n           compute_interchange :        4    --n/a--   1.81e-01    --n/a--   7.23e-01    --n/a--     18.922   3.77e+09   8.12e+05\n                       do_work :        4    --n/a--   9.44e-01    --n/a--   3.78e+00    --n/a--     98.851   8.10e+09   2.92e+06\n                    freeMatrix :       12    --n/a--   2.07e-04    --n/a--   2.49e-03    --n/a--      0.065   1.13e+06   6.30e+03\n                    initialize :       12    --n/a--   3.58e-03    --n/a--   4.29e-02    --n/a--      1.124   2.21e+07   3.80e+05\n                          main :        1    --n/a--   9.54e-01    --n/a--   9.54e-01    --n/a--     24.978   2.03e+09   7.66e+05\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------", 
            "title": "With PAPI"
        }, 
        {
            "location": "/usecases/#csv-output", 
            "text": "While APEX is not designed for post-mortem performance analysis, you can export the data that APEX collected.  If you set the APEX_CSV_OUTPUT environment variable to 1, APEX will also dump the timer statistics as a CSV file:  khuck@ktau:~/src/xpress-apex$ cat apex.0.csv  task , num calls , total cycles , total microseconds , PAPI_TOT_INS , PAPI_L2_TCM  allocateMatrix ,12,704195504,264717,1615804,9100 compute ,4,7290209200,2740489,4306522734,1709040 compute_interchange ,4,1922797744,722806,3769652571,812196 do_work ,4,10044907856,3776018,8101109302,2922142 freeMatrix ,12,6613336,2486,1132717,6301 initialize ,12,114177592,42921,22093639,379785 main ,1,2538202992,954145,2025172707,766218", 
            "title": "CSV output"
        }, 
        {
            "location": "/usecases/#with-tau", 
            "text": "If APEX is configured with TAU support, then APEX measurements will be forwarded to TAU and recorded as a TAU profile.  In addition, all other TAU features are supported, including sampling, MPI measurement, I/O measurement, tracing, etc. To configure APEX with TAU, specify the flags -DUSE_TAU, -DTAU_ROOT, -DTAU_ARCH, and -DTAU_OPTIONS. For example, if TAU was configured with \"./configure -pthread\" on an x86_64 Linux machine, the APEX configuration options would be \"-DUSE_TAU=1 -DTAU_ROOT=/path/to/tau -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-pthread\".  Here is a suggested configuration for TAU on x86-Linux to use with APEX (some systems require special flags - please contact the maintaners if you are interested):  # download the latest TAU release\nwget http://www.cs.uoregon.edu/research/paracomp/tau/tauprofile/dist/tau_latest.tar.gz\n# expand the tar file\ntar -xvzf tau_latest.tar.gz\ncd tau-2.25\n# configure TAU\n./configure -papi=/usr/local/papi/5.3.2 -pthread -prefix=/usr/local/tau/2.25\n# build\nmake -j install\n# set our path to include the new TAU installation\nexport PATH=$PATH:/usr/local/tau/2.25/x86_64/bin  Here is a suggested configuration for APEX to use the above TAU installation:  cd xpress-apex\nmkdir build-tau\ncd build-tau\ncmake -DBUILD_EXAMPLES=TRUE -DBUILD_TESTS=TRUE -DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-papi-pthread \\\n-DBUILD_BFD=TRUE -DBUILD_ACTIVEHARMONY=TRUE -DCMAKE_INSTALL_PREFIX=../install-tau ..\nmake\nmake tests\nmake install  After configuring, building and installing TAU and then configuring, building and installing APEX, the TAU profiling is enabled by setting the environment variable \"APEX_TAU=1\".  After executing an example (say 'matmult'), there should be profile.* files in the working directory:  khuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls profile.*\nprofile.0.0.0  profile.0.0.1  profile.0.0.2  profile.0.0.3  profile.0.0.4  profile.0.0.5  If the TAU analysis utilties are in your path, you can execute  paraprof  to view the profiles:  khuck@ktau:~/src/xpress-apex$ paraprof  ...which should launch the ParaProf profile viewer/analysis program. The profile should look something like the following (for a complete manual on using ParaProf, see  the TAU website ).    If you want to collect a TAU trace, you would enable the appropriate TAU environment variable (TAU_TRACE=1), and then re-run the example.  After the execution, the trace files need to be merged (using tau_treemerge.pl) and then converted (with tau2slog2) to be viewed with the Jumpshot trace viewer (included with TAU):  khuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ export TAU_TRACE=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls *.edf *.trc\nevents.0.edf        tautrace.0.0.1.trc  tautrace.0.0.3.trc  tautrace.0.0.5.trc\ntautrace.0.0.0.trc  tautrace.0.0.2.trc  tautrace.0.0.4.trc\n\n# merge the trace\nkhuck@ktau:~/src/xpress-apex$ tau_treemerge.pl \n/home/khuck/src/tau2/x86_64/bin/tau_merge -m tau.edf -e events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf tautrace.0.0.0.trc tautrace.0.0.1.trc tautrace.0.0.2.trc tautrace.0.0.3.trc tautrace.0.0.4.trc tautrace.0.0.5.trc tau.trc\ntautrace.0.0.0.trc: 34 records read.\ntautrace.0.0.1.trc: 8 records read.\ntautrace.0.0.2.trc: 8 records read.\ntautrace.0.0.3.trc: 30 records read.\ntautrace.0.0.4.trc: 30 records read.\ntautrace.0.0.5.trc: 30 records read.\n\n# convert the trace\nkhuck@ktau:~/src/xpress-apex$ tau2slog2 tau.trc tau.edf -o tau.slog2\n140 records initialized.  Processing.\n2 Records read. 1% converted\n4 Records read. 2% converted\n6 Records read. 4% converted\n8 Records read. 5% converted\n10 Records read. 7% converted\n12 Records read. 8% converted\n14 Records read. 10% converted\n16 Records read. 11% converted\n18 Records read. 12% converted\n20 Records read. 14% converted\n22 Records read. 15% converted\n24 Records read. 17% converted\n26 Records read. 18% converted\n28 Records read. 20% converted\n30 Records read. 21% converted\n32 Records read. 22% converted\n34 Records read. 24% converted\n36 Records read. 25% converted\n38 Records read. 27% converted\n40 Records read. 28% converted\n42 Records read. 30% converted\n44 Records read. 31% converted\n46 Records read. 32% converted\n48 Records read. 34% converted\n50 Records read. 35% converted\n52 Records read. 37% converted\n54 Records read. 38% converted\n56 Records read. 40% converted\n58 Records read. 41% converted\n60 Records read. 42% converted\n62 Records read. 44% converted\n64 Records read. 45% converted\n66 Records read. 47% converted\n68 Records read. 48% converted\n70 Records read. 50% converted\n72 Records read. 51% converted\n74 Records read. 52% converted\n76 Records read. 54% converted\n78 Records read. 55% converted\n80 Records read. 57% converted\n82 Records read. 58% converted\n84 Records read. 60% converted\n86 Records read. 61% converted\n88 Records read. 62% converted\n90 Records read. 64% converted\n92 Records read. 65% converted\n94 Records read. 67% converted\n96 Records read. 68% converted\n98 Records read. 70% converted\n100 Records read. 71% converted\n102 Records read. 72% converted\n104 Records read. 74% converted\n106 Records read. 75% converted\n108 Records read. 77% converted\n110 Records read. 78% converted\n112 Records read. 80% converted\n114 Records read. 81% converted\n116 Records read. 82% converted\n118 Records read. 84% converted\n120 Records read. 85% converted\n122 Records read. 87% converted\n124 Records read. 88% converted\n1521 enters: 0 exits: 0\n126 Records read. 90% converted\n1521 enters: 0 exits: 0\n128 Records read. 91% converted\n130 Records read. 92% converted\n1521 enters: 0 exits: 0\n132 Records read. 94% converted\n1521 enters: 0 exits: 0\n134 Records read. 95% converted\n136 Records read. 97% converted\n1521 enters: 0 exits: 0\n138 Records read. 98% converted\n1521 enters: 0 exits: 0\n140 Records read. 100% converted\nReached end of trace file.\nGetting YMap, Maxnode: 0, Maxthread: 5\n     SLOG-2 Header:\nversion = SLOG 2.0.6\nNumOfChildrenPerNode = 2\nTreeLeafByteSize = 65536\nMaxTreeDepth = 0\nMaxBufferByteSize = 1960\nCategories  is FBinfo(641 @ 2068)\nMethodDefs  is FBinfo(0 @ 0)\nLineIDMaps  is FBinfo(197 @ 2709)\nTreeRoot    is FBinfo(1960 @ 108)\nTreeDir     is FBinfo(38 @ 2906)\nAnnotations is FBinfo(0 @ 0)\nPostamble   is FBinfo(0 @ 0)\n\n1521 enters: 0 exits: 0\n\nNumber of Drawables = 58\ntimeElapsed between 1   2 = 67 msec\ntimeElapsed between 2   3 = 28 msec\n\n# open jumpshot\nkhuck@ktau:~/src/xpress-apex$ jumpshot tau.slog2", 
            "title": "With TAU"
        }, 
        {
            "location": "/usecases/#policy-rules-and-runtime-adaptation", 
            "text": "...Coming soon!", 
            "title": "Policy Rules and Runtime Adaptation"
        }, 
        {
            "location": "/environment/", 
            "text": "There are a number of environment variables that control APEX behavior\nat runtime. The variables can be defined in the environment before \napplication execution, or specified in a file called \napex.conf\n in the\ncurrent execution directory.\n\n\n\n\n\n\n\n\nEnvironment Variable\n\n\nDefault Value\n\n\nValid Values\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAPEX_SCREEN_OUTPUT\n\n\n1\n\n\n0,1\n\n\nOutput APEX options at entry, and performance summary at exit\n\n\n\n\n\n\nAPEX_PROFILE_OUTPUT\n\n\n0\n\n\n0,1\n\n\nOutput TAU profile of performance summary\n\n\n\n\n\n\nAPEX_CSV_OUTPUT\n\n\n0\n\n\n0,1\n\n\nOutput CSV profile of performance summary\n\n\n\n\n\n\nAPEX_TASKGRAPH_OUTPUT\n\n\n0\n\n\n0,1\n\n\nOutput graphviz reduced taskgraph\n\n\n\n\n\n\nAPEX_POLICY\n\n\n1\n\n\n0,1\n\n\nEnable APEX policy listener and execute registered policies\n\n\n\n\n\n\nAPEX_PROC_STAT\n\n\n1\n\n\n0,1\n\n\nPeriodically read data from /proc/stat\n\n\n\n\n\n\nAPEX_PROC_CPUINFO\n\n\n0\n\n\n0,1\n\n\nRead data (once) from /proc/cpuinfo\n\n\n\n\n\n\nAPEX_PROC_MEMINFO\n\n\n0\n\n\n0,1\n\n\nPeriodically read data from /proc/meminfo\n\n\n\n\n\n\nAPEX_PROC_NET_DEV\n\n\n0\n\n\n0,1\n\n\nPeriodically read data from /proc/net/dev\n\n\n\n\n\n\nAPEX_PROC_SELF_STATUS\n\n\n0\n\n\n0,1\n\n\nPeriodically read data from /proc/self/status\n\n\n\n\n\n\nAPEX_MEASURE_CONCURRENCY\n\n\n0\n\n\n0,1\n\n\nPeriodically sample thread activity and output report at exit\n\n\n\n\n\n\nAPEX_MEASURE_CONCURRENCY_PERIOD\n\n\n1000000\n\n\nInteger\n\n\nThread concurrency sampling period, in microseconds\n\n\n\n\n\n\nAPEX_TAU\n\n\n0\n\n\n0,1\n\n\nEnable TAU profiling (if APEX is configured with TAU).\n\n\n\n\n\n\nAPEX_THROTTLE_CONCURRENCY\n\n\n0\n\n\n0,1\n\n\nDeactivate/activate threads for policy support\n\n\n\n\n\n\nAPEX_THROTTLING_MIN_THREADS\n\n\n1\n\n\n0,1\n\n\nMinimum threads allowed\n\n\n\n\n\n\nAPEX_THROTTLING_MAX_THREADS\n\n\n8\n\n\n0,1\n\n\nMaximum threads allowed\n\n\n\n\n\n\nAPEX_THROTTLE_ENERGY\n\n\n0\n\n\n0,1\n\n\nEnable energy throttling\n\n\n\n\n\n\nAPEX_THROTTLING_MIN_WATTS\n\n\n150\n\n\nInteger\n\n\nMinimum Watt threshold\n\n\n\n\n\n\nAPEX_THROTTLING_MAX_WATTS\n\n\n300\n\n\nInteger\n\n\nMaximum Watt threshold\n\n\n\n\n\n\nAPEX_PTHREAD_WRAPPER_STACK_SIZE\n\n\n0\n\n\n16k-8M\n\n\nWhen wrapping pthread_create, use this size for the stack.\n\n\n\n\n\n\nAPEX_PAPI_METRICS\n\n\nnull\n\n\nspace-delimited string of metric names\n\n\nList of metrics to be measured by APEX when timers are used. Only meaningful if APEX is configured with PAPI support.  Any supported metric from \npapi_avail\n (\nsee PAPI Documentation\n) can be used.", 
            "title": "Useful Environment Variables"
        }, 
        {
            "location": "/examples/", 
            "text": "HPX-3 and 1D stencil\n\n\n...coming soon...\n\n\nHPX-5 and LULESH\n\n\n...coming soon...\n\n\nHPX-5 and SSSP\n\n\n...coming soon...\n\n\nHPX-5 and MiniGhost\n\n\n...coming soon...\n\n\nOpenMP and LULESH 2.0\n\n\n...coming soon...\n\n\nOpenMP and NPB 3.2.1\n\n\n...coming soon...\n\n\nMPI applications\n\n\n...coming soon...", 
            "title": "Research Examples"
        }, 
        {
            "location": "/examples/#hpx-3-and-1d-stencil", 
            "text": "...coming soon...", 
            "title": "HPX-3 and 1D stencil"
        }, 
        {
            "location": "/examples/#hpx-5-and-lulesh", 
            "text": "...coming soon...", 
            "title": "HPX-5 and LULESH"
        }, 
        {
            "location": "/examples/#hpx-5-and-sssp", 
            "text": "...coming soon...", 
            "title": "HPX-5 and SSSP"
        }, 
        {
            "location": "/examples/#hpx-5-and-minighost", 
            "text": "...coming soon...", 
            "title": "HPX-5 and MiniGhost"
        }, 
        {
            "location": "/examples/#openmp-and-lulesh-20", 
            "text": "...coming soon...", 
            "title": "OpenMP and LULESH 2.0"
        }, 
        {
            "location": "/examples/#openmp-and-npb-321", 
            "text": "...coming soon...", 
            "title": "OpenMP and NPB 3.2.1"
        }, 
        {
            "location": "/examples/#mpi-applications", 
            "text": "...coming soon...", 
            "title": "MPI applications"
        }, 
        {
            "location": "/refman/", 
            "text": "API Reference Manual\n\n\nThe source code is instrumented with Doxygen comments, and the API reference manual can be generated by executing 'make doc' in the build directory, after CMake configuration.  A fairly recent version of the API reference documentation is also available here: \nhttp://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html", 
            "title": "API Reference manual"
        }, 
        {
            "location": "/refman/#api-reference-manual", 
            "text": "The source code is instrumented with Doxygen comments, and the API reference manual can be generated by executing 'make doc' in the build directory, after CMake configuration.  A fairly recent version of the API reference documentation is also available here:  http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html", 
            "title": "API Reference Manual"
        }
    ]
}