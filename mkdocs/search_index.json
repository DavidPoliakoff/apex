{
    "docs": [
        {
            "location": "/", 
            "text": "APEX: Autonomic Performance Environment for eXascale\n\n\nOne of the key components of the XPRESS project is a new approach to performance observation, measurement, analysis and runtime decision making in order to optimize performance. The particular challenges of accurately measuring the performance characteristics of ParalleX \n[1]\n applications (as well as other asynchronous multitasking runtime architectures) requires a new approach to parallel performance observation. The standard model of multiple operating system processes and threads observing themselves in a first-person manner while writing out performance profiles or traces for offline analysis will not adequately capture the full execution context, nor provide opportunities for runtime adaptation within OpenX. The approach taken in the XPRESS project is a new performance measurement system, called (Autonomic Performance Environment for eXascale). APEX includes methods for information sharing between the layers of the software stack, from the hardware through operating and runtime systems, all the way to domain specific or legacy applications. The performance measurement components incorporate relevant information across stack layers, with merging of third-person performance observation of node-level and global resources, remote processes, and both operating and runtime system threads.  For a complete academic description of APEX, see the publication \"APEX: An Autonomic Performance Environment for eXascale\" \n[2]\n.\n\n\nIn short, APEX is an introspection and runtime adaptation library for asynchronous multitasking runtime systems. However, APEX is not \nonly\n useful for AMT/AMR runtimes running on future exascale systems - it can be used by any application wanting to perform runtime adaptation to deal with heterogeneous and/or variable environments.\n\n\nIntrospection\n\n\nAPEX provides an API for measuring actions within a runtime. The API includes methods for timer start/stop, as well as sampled counter values. APEX is designed to be integrated into a runtime, library and/or application and provide performance introspection for the purpose of runtime adaptation. While APEX \ncan\n provide rudimentary post-mortem performance analysis measurement, there are many other performance measurement tools that perform that task much better (such as TAU http://tau.uoregon.edu).  That said, APEX includes an event listener that integrates with the TAU measurement system, so APEX events can be forwarded to TAU and collected in a TAU profile and/or trace to be used for post-mortem performance anlaysis.\n\n\nRuntime Adaptation\n\n\nAPEX provides a mechanism for dynamic runtime behavior, either for autotuning or adaptation to changing environment.  The infrastruture that provides the adaptation is the Policy Engine, which executes policies either periodically or triggered by events. The policies have access to the performance state as observed by the APEX introspection API. APEX is integrated with Active Harmony (http://www.dyninst.org/harmony) to provide dynamic search for autotuning.\n\n\nReferences\n\n\n\n\n Thomas Sterling, Daniel Kogler, Matthew Anderson, and Maciej Brodowicz. \"SLOWER: A performance model for Exascale computing\". \nSupercomputing Frontiers and Innovations\n, 1:42\u201357, September 2014. \nhttp://superfri.org/superfri/article/view/10\n\n\n Kevin A. Huck, Allan Porterfield, Nick Chaimov, Hartmut Kaiser, Allen D. Malony, Thomas Sterling, Rob Fowler. \"An Autonomic Performance Environment for eXascale\", \nJournal of Supercomputing Frontiers and Innovations\n, 2015. \nhttp://superfri.org/superfri/article/view/64", 
            "title": "Home"
        }, 
        {
            "location": "/#apex-autonomic-performance-environment-for-exascale", 
            "text": "One of the key components of the XPRESS project is a new approach to performance observation, measurement, analysis and runtime decision making in order to optimize performance. The particular challenges of accurately measuring the performance characteristics of ParalleX  [1]  applications (as well as other asynchronous multitasking runtime architectures) requires a new approach to parallel performance observation. The standard model of multiple operating system processes and threads observing themselves in a first-person manner while writing out performance profiles or traces for offline analysis will not adequately capture the full execution context, nor provide opportunities for runtime adaptation within OpenX. The approach taken in the XPRESS project is a new performance measurement system, called (Autonomic Performance Environment for eXascale). APEX includes methods for information sharing between the layers of the software stack, from the hardware through operating and runtime systems, all the way to domain specific or legacy applications. The performance measurement components incorporate relevant information across stack layers, with merging of third-person performance observation of node-level and global resources, remote processes, and both operating and runtime system threads.  For a complete academic description of APEX, see the publication \"APEX: An Autonomic Performance Environment for eXascale\"  [2] .  In short, APEX is an introspection and runtime adaptation library for asynchronous multitasking runtime systems. However, APEX is not  only  useful for AMT/AMR runtimes running on future exascale systems - it can be used by any application wanting to perform runtime adaptation to deal with heterogeneous and/or variable environments.", 
            "title": "APEX: Autonomic Performance Environment for eXascale"
        }, 
        {
            "location": "/#introspection", 
            "text": "APEX provides an API for measuring actions within a runtime. The API includes methods for timer start/stop, as well as sampled counter values. APEX is designed to be integrated into a runtime, library and/or application and provide performance introspection for the purpose of runtime adaptation. While APEX  can  provide rudimentary post-mortem performance analysis measurement, there are many other performance measurement tools that perform that task much better (such as TAU http://tau.uoregon.edu).  That said, APEX includes an event listener that integrates with the TAU measurement system, so APEX events can be forwarded to TAU and collected in a TAU profile and/or trace to be used for post-mortem performance anlaysis.", 
            "title": "Introspection"
        }, 
        {
            "location": "/#runtime-adaptation", 
            "text": "APEX provides a mechanism for dynamic runtime behavior, either for autotuning or adaptation to changing environment.  The infrastruture that provides the adaptation is the Policy Engine, which executes policies either periodically or triggered by events. The policies have access to the performance state as observed by the APEX introspection API. APEX is integrated with Active Harmony (http://www.dyninst.org/harmony) to provide dynamic search for autotuning.", 
            "title": "Runtime Adaptation"
        }, 
        {
            "location": "/#references", 
            "text": "Thomas Sterling, Daniel Kogler, Matthew Anderson, and Maciej Brodowicz. \"SLOWER: A performance model for Exascale computing\".  Supercomputing Frontiers and Innovations , 1:42\u201357, September 2014.  http://superfri.org/superfri/article/view/10   Kevin A. Huck, Allan Porterfield, Nick Chaimov, Hartmut Kaiser, Allen D. Malony, Thomas Sterling, Rob Fowler. \"An Autonomic Performance Environment for eXascale\",  Journal of Supercomputing Frontiers and Innovations , 2015.  http://superfri.org/superfri/article/view/64", 
            "title": "References"
        }, 
        {
            "location": "/feature/", 
            "text": "APEX: Motivation\n\n\nFrequently, software components or even entire applications run into a situation where the context of the execution environment has changed in some way (or does not meet assumptions). In those situations, the software requires some mechanism for evaluating its own performance and that of the underlying runtime system, operating system and hardware. The types of adaptation that the software wants to do could include:\n\n\n\n\nControlling concurrency\n\n\nto improve energy efficiency\n\n\nfor performance\n\n\n\n\n\n\nParametric variability\n\n\nadjust the decomposition granularity for this machine / dataset\n\n\nchoose a different algorithm for better performance/accuracy\n\n\nchoose a different preconditioner for better performance/accuracy\n\n\nchoose a different solver for better performance/accuracy\n\n\n\n\n\n\nLoad Balancing\n\n\nwhen to perform AGAS migration?\n\n\nwhen to perform repartitioning?\n\n\nwhen to perform data exchanges?\n\n\n\n\n\n\nParallel Algorithms (for_each\u2026) - choose a different execution model\n\n\nseparate \nwhat\n from \nhow\n\n\n\n\n\n\nAddress the \u201cSLOW(ER)\u201d performance model\n\n\navoid \nS\ntarvation\n\n\nreduce \nL\natency\n\n\nreduce \nO\nverhead\n\n\nreduce \nW\naiting\n\n\nreduce \nE\nnergy consumption\n\n\nimprove \nR\nesiliency\n\n\n\n\n\n\n\n\nAPEX provides both \nperformance awareness\n and \nperformance adaptation\n.\n\n\n\n\nAPEX provides top-down and bottom-up performance mapping and feedback.\n\n\nAPEX exposes node-wide resource utilization data and analysis, energy consumption, and health information in real time\n\n\nSoftware can subsequently associate performance state with policy for feedback control\n\n\n\n\n\n\nAPEX introspection\n\n\nOS: track system resources, utilization, job contention, overhead\n\n\nRuntime (HPX, HPX-5, OpenMP...): track threads, queues, concurrency, remote operations, parcels, memory management\n\n\nApplication timer / counter observation\n\n\n\n\n\n\n\n\n\n\nAbove: APEX architecture diagram (when linked with an HPX application). The application and runtime send events to the APEX instrumentation API, which updates the performance state. The Policy Engine executes policies that change application behavior based on rule outcomes.\n\n\nIntrospection\n\n\nAPEX collects data through \ninspectors\n. The synchronous data collection uses an event API and event \nlisteners\n. The API includes events for:\n\n\n\n\nInitialize, terminate, new thread \n\n\nadded to the HPX thread scheduler\n\n\nadded to the HPX-5 thread scheduler\n\n\nadded to the OpenMP runtime using the OMPT interface\n\n\nadded to the pthread runtime by wrapping the pthread API calls\n\n\n\n\n\n\nTimer start, stop, yield, resume \n\n\nadded to HPX task scheduler\n\n\nadded to HPX-5 task scheduler\n\n\nadded to the OpenMP runtime using the OMPT interface\n\n\nadded to the pthread runtime by wrapping the pthread API calls\n\n\n\n\n\n\nSampled values\n\n\ncounters from HPX, HPX-5\n\n\n\n\n\n\nCustom events (meta-events)\n\n\nuseful for triggering policies\n\n\n\n\n\n\n\n\nAsynchonous data collection does not rely on events, but occurs periodically.  APEX exploits access to performance data from lower stack components (i.e. the runtime) or by reading from the RCR blackboard (i.e., power, energy). Other operating system and hardware health data is collected through other interfaces:\n\n\n\n\n/proc/stat\n\n\n/proc/cpuinfo\n\n\n/proc/meminfo\n\n\n/proc/net/dev\n\n\n/proc/self/status\n\n\nlm_sensors\n\n\npower measurements \n\n\n\n\nEvent Listeners\n\n\nThere are a number of listeners in APEX that are triggered by the events passed in through the API. For example, the \nProfiling Listener\n records events related to maintaining the performance state.\n\n\n\n\nStart Event: records the name/address of the timer, gets a timestamp (using rdtsc), returns a profiler handle\n\n\nStop Event: gets a timestamp, puts the profiler object in a queue for back-end processing and returns\n\n\nSample Event: put the name \n value in the queue\n\n\n\n\nInternally to APEX, there is an asynchronous consumer thread that processes profiler objects and samples to build a performance profile (in HPX, this thread is processed/scheduled as an HPX thread/task).\n\n\nThe TAU Listener (used for postmortem analysis) synchronously passes all measurement events to TAU to build an offline profile or trace. TAU will also capture any other events for which it is configured, including MPI, memory, file I/O, etc.\n\n\nThe concurrency listener (also used for postmortem analysis) maintains a timeline of total concurrency, periodically sampled from  within APEX.\n\n\n\n\nStart event: push timer ID on stack\n\n\nStop event: pop timer ID off stack\n\n\n\n\nAn asynchronous consumer thread periodically logs the current timer for each thread. This thread will output a concurrency data report and gnuplot script at APEX termination. \n\n\nPolicy Listener\n\n\nPolicies are rules that decide on outcomes based on observed state. \nTriggered policies are invoked by introspection API events.\nPeriodic policies are run periodically on asynchronous thread.\nPolices are registered with the Policy Engine at program startup by runtime code and/or from the application.\nApplications, runtimes, and the OS can register callback functions to be executed. \nCallback functions define the policy rules - \u201cIf x \n y then...(take some action!)\u201d.\n\n\n\n\nEnables runtime adaptation using introspection data\n\n\nEngages actuators across stack layers\n\n\nIs also used to involve online auto-tuning support", 
            "title": "Feature Overview"
        }, 
        {
            "location": "/feature/#apex-motivation", 
            "text": "Frequently, software components or even entire applications run into a situation where the context of the execution environment has changed in some way (or does not meet assumptions). In those situations, the software requires some mechanism for evaluating its own performance and that of the underlying runtime system, operating system and hardware. The types of adaptation that the software wants to do could include:   Controlling concurrency  to improve energy efficiency  for performance    Parametric variability  adjust the decomposition granularity for this machine / dataset  choose a different algorithm for better performance/accuracy  choose a different preconditioner for better performance/accuracy  choose a different solver for better performance/accuracy    Load Balancing  when to perform AGAS migration?  when to perform repartitioning?  when to perform data exchanges?    Parallel Algorithms (for_each\u2026) - choose a different execution model  separate  what  from  how    Address the \u201cSLOW(ER)\u201d performance model  avoid  S tarvation  reduce  L atency  reduce  O verhead  reduce  W aiting  reduce  E nergy consumption  improve  R esiliency     APEX provides both  performance awareness  and  performance adaptation .   APEX provides top-down and bottom-up performance mapping and feedback.  APEX exposes node-wide resource utilization data and analysis, energy consumption, and health information in real time  Software can subsequently associate performance state with policy for feedback control    APEX introspection  OS: track system resources, utilization, job contention, overhead  Runtime (HPX, HPX-5, OpenMP...): track threads, queues, concurrency, remote operations, parcels, memory management  Application timer / counter observation      Above: APEX architecture diagram (when linked with an HPX application). The application and runtime send events to the APEX instrumentation API, which updates the performance state. The Policy Engine executes policies that change application behavior based on rule outcomes.", 
            "title": "APEX: Motivation"
        }, 
        {
            "location": "/feature/#introspection", 
            "text": "APEX collects data through  inspectors . The synchronous data collection uses an event API and event  listeners . The API includes events for:   Initialize, terminate, new thread   added to the HPX thread scheduler  added to the HPX-5 thread scheduler  added to the OpenMP runtime using the OMPT interface  added to the pthread runtime by wrapping the pthread API calls    Timer start, stop, yield, resume   added to HPX task scheduler  added to HPX-5 task scheduler  added to the OpenMP runtime using the OMPT interface  added to the pthread runtime by wrapping the pthread API calls    Sampled values  counters from HPX, HPX-5    Custom events (meta-events)  useful for triggering policies     Asynchonous data collection does not rely on events, but occurs periodically.  APEX exploits access to performance data from lower stack components (i.e. the runtime) or by reading from the RCR blackboard (i.e., power, energy). Other operating system and hardware health data is collected through other interfaces:   /proc/stat  /proc/cpuinfo  /proc/meminfo  /proc/net/dev  /proc/self/status  lm_sensors  power measurements", 
            "title": "Introspection"
        }, 
        {
            "location": "/feature/#event-listeners", 
            "text": "There are a number of listeners in APEX that are triggered by the events passed in through the API. For example, the  Profiling Listener  records events related to maintaining the performance state.   Start Event: records the name/address of the timer, gets a timestamp (using rdtsc), returns a profiler handle  Stop Event: gets a timestamp, puts the profiler object in a queue for back-end processing and returns  Sample Event: put the name   value in the queue   Internally to APEX, there is an asynchronous consumer thread that processes profiler objects and samples to build a performance profile (in HPX, this thread is processed/scheduled as an HPX thread/task).  The TAU Listener (used for postmortem analysis) synchronously passes all measurement events to TAU to build an offline profile or trace. TAU will also capture any other events for which it is configured, including MPI, memory, file I/O, etc.  The concurrency listener (also used for postmortem analysis) maintains a timeline of total concurrency, periodically sampled from  within APEX.   Start event: push timer ID on stack  Stop event: pop timer ID off stack   An asynchronous consumer thread periodically logs the current timer for each thread. This thread will output a concurrency data report and gnuplot script at APEX termination.", 
            "title": "Event Listeners"
        }, 
        {
            "location": "/feature/#policy-listener", 
            "text": "Policies are rules that decide on outcomes based on observed state. \nTriggered policies are invoked by introspection API events.\nPeriodic policies are run periodically on asynchronous thread.\nPolices are registered with the Policy Engine at program startup by runtime code and/or from the application.\nApplications, runtimes, and the OS can register callback functions to be executed. \nCallback functions define the policy rules - \u201cIf x   y then...(take some action!)\u201d.   Enables runtime adaptation using introspection data  Engages actuators across stack layers  Is also used to involve online auto-tuning support", 
            "title": "Policy Listener"
        }, 
        {
            "location": "/install/", 
            "text": "Downloading APEX\n\n\nAPEX is open source, and available on Github at \nhttp//github.com/khuck/xpress-apex\n.\n\n\nFor stability, most users will want to download the most recent release of APEX (for example, v0.5):\n\n\nwget https://github.com/khuck/xpress-apex/archive/v0.5.tar.gz\ntar -xvzf v0.5.tar.gz\ncd xpress-apex-0.5\n\n\n\n\nOther users may want to work with the most recent code available, in which case you can clone the git repo:\n\n\ngit clone https://github.com/khuck/xpress-apex.git\ncd xpress-apex\n\n\n\n\nInstallation Option 1: Configuring and building APEX with bootstrap scripts\n\n\nThis option is useful for HPC resources where a configuration script already exists, such as Edison@NERSC, Cori@NERSC, Babbage@NERSC, etc.  To use this option, copy and modify ./bootstrap-configs/bootstrap-$arch.sh as necessary, and run it.\n\n\nInstallation Option 2: Configuring and building APEX with CMake directly (recommended for most users)\n\n\nAPEX is built with CMake. The minimum CMake settings needed for APEX are:\n\n\n\n\n-DCMAKE_INSTALL_PREFIX= some path to an installation location\n\n\n-DCMAKE_BUILD_TYPE= one of Release, Debug, or RelWithDebInfo (recommended)\n\n\n\n\nWhen building on Intel Phi, Boost is required if the compiler toolset does not include the latest GNU C++11 support.\n\n\n\n\n-DBOOST_ROOT= the path to a Boost installation, 1.54 or newer\n\n\n\n\nNote:\n \nIf the BOOST_ROOT environment variable is set to a working Boost installation directory, CMake will find it automatically. If Boost is not installed locally, use the -DBUILD_BOOST=TRUE option, which will automatically download and build Boost as a subproject of APEX.\n\n\nThe process for building APEX is:\n\n\n1) Get the code (see above)\n\n\n2) Enter the repo directory, make a build directory:\n\n\ncd xpress-apex-0.5\nmkdir build\ncd build\n\n\n\n\n3) configure using CMake:\n\n\ncmake -DCMAKE_INSTALL_PREFIX=\ninstallation-path\n -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n\n\n\n\nIf Boost is required (Intel Phi):\n\n\ncmake -DBOOST_ROOT=\npath-to-boost\n -DCMAKE_INSTALL_PREFIX=\ninstallation-path\n -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n\n\n\n\n4) build with make:\n\n\nmake\nmake test\nmake doc\nmake install\n\n\n\n\nOther CMake settings, depending on your needs/wants\n\n\nNote 1:\n \nThe \nrecommended\n packages include:\n\n\n\n\nActive Harmony\n - for autotuning policies\n\n\nOMPT\n - if OpenMP support is required (\nSee the OpenMP use case\n for an example)\n\n\nBinutils/BFD\n - if your runtime/application uses instruction addresses to identify timers, e.g. HPX-5 and OpenMP\n\n\nTAU\n \nor\n \nPAPI\n - if you want post-mortem performance analysis (\nSee the TAU use case\n for an example) or your policies will require hardware counters (\nSee the PAPI use case\n for an example)\n\n\nJEMalloc/TCMalloc\n - if your application is not already using a heap manager - see Note 2, below\n\n\n\n\nNote 2:\n \nTCMalloc or JEMalloc will speed up memory allocations \nsignificantly\n in APEX (and in your application). HOWEVER, If your application already uses TCMalloc, JEMalloc or TBBMalloc, \nDO NOT\n configure APEX with TCMalloc or JEMalloc. They will be included at application link time, and may conflict with the version detected by and linked into APEX.\n\n\nThere are several utility libraries that provide additional functionality in APEX. Not all libraries are required, but some are recommended.  For the following options, the default values are in \nitalics\n.\n\n\n\n\n-DBUILD_BOOST=\n\n  TRUE or \nFALSE\n.  In the event that Boost isn't pre-installed on your system, this option forces CMake to download and build Boost as part of the APEX project.\n\n\n-DUSE_ACTIVEHARMONY=\n\n  \nTRUE\n or FALSE.  Active Harmony is a library that intelligently searches for parametric combinations to support adapting to heterogeneous and changing environments.  For more information, see \nhttp://www.dyninst.org/harmony\n.  APEX uses Active Harmony for runtime adaptation.\n\n\n-DACTIVEHARMONY_ROOT=\n\n  the path to Active Harmony, or set the ACTIVEHARMONY_ROOT environment variable before running cmake.  It should be noted that if Active Harmony is not specified and -DUSE_ACTIVEHARMONY is TRUE or not set, APEX will download and build Active Harmony as a CMake project. To disable Active Harmony entirely, specify -DUSE_ACTIVEHARMONY=FALSE.\n\n\n-DBUILD_ACTIVEHARMONY=\n\n  TRUE or \nFALSE\n.  Whether or not Active Harmony is installed on the system, this option forces CMake to automatically download and build Active Harmony as part of the APEX project.\n\n\n-DUSE_OMPT=\n\n  TRUE or \nFALSE\n.  OMPT is a proposed standard for OpenMP runtimes to provide callback hooks to performance tools. For more information, see \nhttp://openmp.org/mp-documents/ompt-tr2.pdf\n.  APEX has support for most OMPT OpenMP trace events. See \nthe OpenMP use case\n for an example.\n\n\n-DOMPT_ROOT=\n\n  the path to OMPT, or set the OMPT_ROOT environment variable before running cmake.\n\n\n-DBUILD_OMPT=\n\n  TRUE or \nFALSE\n. Whether or not an OpenMP library with OMPT support is found by CMake, this option forces CMake to automatically download and build an OpenMP runtime with OMPT support as part of the APEX project.\n\n\n-DUSE_BFD=\n\n  TRUE or \nFALSE\n.  APEX uses libbfd to convert instruction addresses to source code locations. BFD support is useful for generating human-readable output for summaries and concurrency graphs. Libbfd is not required for runtime adaptation.\n\n\n-DBFD_ROOT=\n\n  path to Binutils, or set the BFD_ROOT environment variable.\n\n\n-DBUILD_BFD=\n\n  TRUE or FALSE.  Whether or not binutils is found by CMake, this option forces CMake to automatically download and build binutils as part of the APEX project.\n\n\n-DUSE_TAU=\n\n  TRUE or \nFALSE\n.  TAU (Tuning and Analysis Utilities) is a performance measurement and analysis framework for large scale parallel applications. For more information see \nhttp://tau.uoregon.edu\n.  APEX uses TAU to generate profiles for post-mortem performance analysis. See \nthe TAU use case\n for an example.\n\n\n-DTAU_ROOT=\n\n  path to TAU, or set the TAU_ROOT environment variable before running cmake.\n\n\n-DTAU_ARCH=\n\n  the TAU architecture, like x86_64, craycnl, mic_linux, bgq, etc.\n\n\n-DTAU_OPTIONS=\n\n  a TAU configuration with thread support, like -pthread or -icpc-pthread.\n\n\n-DUSE_RCR=\n\n  TRUE or \nFALSE\n.  RCR (Resource Centric Reflection) is a library for system monitoring of resources that require root access.  For more information, see \nhttp://www.renci.org/wp-content/pub/techreports/TR-10-01.pdf\n.  APEX uses RCR to access 'uncore' counters and system health information such as power and energy counters.\n\n\n-DRCR_ROOT=\n\n  the path to RCR, or set the RCR_ROOT environment variable.\n\n\n-DUSE_TCMALLOC=\n\n  TRUE or \nFALSE\n.  TCMalloc is a heap management library distributed as part of Google perftools. For more information, see \nhttps://github.com/gperftools/gperftools\n.  TCMalloc provides faster memory performance in multithreaded environments.\n\n\n-DGPERFTOOLS_ROOT=\n\n  path to gperftools (TCMalloc), or set the GPERFTOOLS_ROOT environment variable before running cmake.\n\n\n-DUSE_JEMALLOC=\n\n  TRUE or \nFALSE\n.  JEMalloc is a heap management library.  For more information, see \nhttp://www.canonware.com/jemalloc/\n.  JEMalloc provides faster memory performance in multithreaded environments.\n\n\n-DJEMALLOC_ROOT=\n\n  path to JEMalloc, or set the JEMALLOC_ROOT environment variable before running cmake.\n\n\n-DUSE_PAPI=\n\n  TRUE or \nFALSE\n.  PAPI (Performance Application Programming Interface) provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors.  For more information, see \nhttp://icl.cs.utk.edu/papi/\n.  APEX uses PAPI to optionally collect hardware counters for timed events.\n\n\n-DPAPI_ROOT=\n\n  some path to PAPI, or set the PAPI_ROOT environment variable before running cmake. See \nthe PAPI use case\n for an example.\n\n\n-DUSE_LM_SENSORS=\n\n  TRUE or \nFALSE\n. Lm_sensors (Linux Monitoring Sensors) is a library for monitoring hardware temperatures and fan speeds. For more information, see \nhttps://en.wikipedia.org/wiki/Lm_sensors\n.  APEX uses lm_sensors to monitor hardware, where available.\n\n\n-DBUILD_EXAMPLES=\n\n  TRUE or \nFALSE\n. Whether or not to build the application examples in APEX.\n\n\n-DBUILD_TESTS=\n\n  \nTRUE\n or FALSE. Whether or not to build the APEX unit tests.\n\n\n-DCMAKE_C_COMPILER=\n\n  \ngcc\n\n\n-DCMAKE_CXX_COMPILER=\n\n  \ng++\n\n\n-DCMAKE_BUILD_TYPE=\n\n  Release, \nDebug\n, RelWithDebInfo. Unfortunately, the cmake default (when not specified) is Debug. For faster performance, configure APEX to build RelWithDebInfo or Release.\n\n\n-DBUILD_SHARED_LIBS=\n\n  TRUE or FALSE\n\n\n-DUSE_MPI=\n\n  TRUE or \nFALSE\n. Whether to build MPI global support and related examples.\n\n\n-DMPI_C_INCLUDE_PATH=\n\n  path to MPI headers\n\n\n-DMPI_CXX_INCLUDE_PATH=\n\n  path to MPI headers\n\n\n-DMPI_C_LIBRARIES=\n\n  paths to MPI libraries, library names\n\n\n-DMPI_CXX_LIBRARIES=\n\n  paths to MPI libraries, library names\n\n\n-DMPI_C_COMPILER=\n\n  mpicc\n\n\n-DMPI_CXX_COMPILER=\n\n  mpicxx", 
            "title": "Getting Started"
        }, 
        {
            "location": "/install/#downloading-apex", 
            "text": "APEX is open source, and available on Github at  http//github.com/khuck/xpress-apex .  For stability, most users will want to download the most recent release of APEX (for example, v0.5):  wget https://github.com/khuck/xpress-apex/archive/v0.5.tar.gz\ntar -xvzf v0.5.tar.gz\ncd xpress-apex-0.5  Other users may want to work with the most recent code available, in which case you can clone the git repo:  git clone https://github.com/khuck/xpress-apex.git\ncd xpress-apex", 
            "title": "Downloading APEX"
        }, 
        {
            "location": "/install/#installation-option-1-configuring-and-building-apex-with-bootstrap-scripts", 
            "text": "This option is useful for HPC resources where a configuration script already exists, such as Edison@NERSC, Cori@NERSC, Babbage@NERSC, etc.  To use this option, copy and modify ./bootstrap-configs/bootstrap-$arch.sh as necessary, and run it.", 
            "title": "Installation Option 1: Configuring and building APEX with bootstrap scripts"
        }, 
        {
            "location": "/install/#installation-option-2-configuring-and-building-apex-with-cmake-directly-recommended-for-most-users", 
            "text": "APEX is built with CMake. The minimum CMake settings needed for APEX are:   -DCMAKE_INSTALL_PREFIX= some path to an installation location  -DCMAKE_BUILD_TYPE= one of Release, Debug, or RelWithDebInfo (recommended)   When building on Intel Phi, Boost is required if the compiler toolset does not include the latest GNU C++11 support.   -DBOOST_ROOT= the path to a Boost installation, 1.54 or newer   Note:   If the BOOST_ROOT environment variable is set to a working Boost installation directory, CMake will find it automatically. If Boost is not installed locally, use the -DBUILD_BOOST=TRUE option, which will automatically download and build Boost as a subproject of APEX.  The process for building APEX is:  1) Get the code (see above)  2) Enter the repo directory, make a build directory:  cd xpress-apex-0.5\nmkdir build\ncd build  3) configure using CMake:  cmake -DCMAKE_INSTALL_PREFIX= installation-path  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..  If Boost is required (Intel Phi):  cmake -DBOOST_ROOT= path-to-boost  -DCMAKE_INSTALL_PREFIX= installation-path  -DCMAKE_BUILD_TYPE=RelWithDebInfo ..  4) build with make:  make\nmake test\nmake doc\nmake install", 
            "title": "Installation Option 2: Configuring and building APEX with CMake directly (recommended for most users)"
        }, 
        {
            "location": "/install/#other-cmake-settings-depending-on-your-needswants", 
            "text": "Note 1:   The  recommended  packages include:   Active Harmony  - for autotuning policies  OMPT  - if OpenMP support is required ( See the OpenMP use case  for an example)  Binutils/BFD  - if your runtime/application uses instruction addresses to identify timers, e.g. HPX-5 and OpenMP  TAU   or   PAPI  - if you want post-mortem performance analysis ( See the TAU use case  for an example) or your policies will require hardware counters ( See the PAPI use case  for an example)  JEMalloc/TCMalloc  - if your application is not already using a heap manager - see Note 2, below   Note 2:   TCMalloc or JEMalloc will speed up memory allocations  significantly  in APEX (and in your application). HOWEVER, If your application already uses TCMalloc, JEMalloc or TBBMalloc,  DO NOT  configure APEX with TCMalloc or JEMalloc. They will be included at application link time, and may conflict with the version detected by and linked into APEX.  There are several utility libraries that provide additional functionality in APEX. Not all libraries are required, but some are recommended.  For the following options, the default values are in  italics .   -DBUILD_BOOST= \n  TRUE or  FALSE .  In the event that Boost isn't pre-installed on your system, this option forces CMake to download and build Boost as part of the APEX project.  -DUSE_ACTIVEHARMONY= \n   TRUE  or FALSE.  Active Harmony is a library that intelligently searches for parametric combinations to support adapting to heterogeneous and changing environments.  For more information, see  http://www.dyninst.org/harmony .  APEX uses Active Harmony for runtime adaptation.  -DACTIVEHARMONY_ROOT= \n  the path to Active Harmony, or set the ACTIVEHARMONY_ROOT environment variable before running cmake.  It should be noted that if Active Harmony is not specified and -DUSE_ACTIVEHARMONY is TRUE or not set, APEX will download and build Active Harmony as a CMake project. To disable Active Harmony entirely, specify -DUSE_ACTIVEHARMONY=FALSE.  -DBUILD_ACTIVEHARMONY= \n  TRUE or  FALSE .  Whether or not Active Harmony is installed on the system, this option forces CMake to automatically download and build Active Harmony as part of the APEX project.  -DUSE_OMPT= \n  TRUE or  FALSE .  OMPT is a proposed standard for OpenMP runtimes to provide callback hooks to performance tools. For more information, see  http://openmp.org/mp-documents/ompt-tr2.pdf .  APEX has support for most OMPT OpenMP trace events. See  the OpenMP use case  for an example.  -DOMPT_ROOT= \n  the path to OMPT, or set the OMPT_ROOT environment variable before running cmake.  -DBUILD_OMPT= \n  TRUE or  FALSE . Whether or not an OpenMP library with OMPT support is found by CMake, this option forces CMake to automatically download and build an OpenMP runtime with OMPT support as part of the APEX project.  -DUSE_BFD= \n  TRUE or  FALSE .  APEX uses libbfd to convert instruction addresses to source code locations. BFD support is useful for generating human-readable output for summaries and concurrency graphs. Libbfd is not required for runtime adaptation.  -DBFD_ROOT= \n  path to Binutils, or set the BFD_ROOT environment variable.  -DBUILD_BFD= \n  TRUE or FALSE.  Whether or not binutils is found by CMake, this option forces CMake to automatically download and build binutils as part of the APEX project.  -DUSE_TAU= \n  TRUE or  FALSE .  TAU (Tuning and Analysis Utilities) is a performance measurement and analysis framework for large scale parallel applications. For more information see  http://tau.uoregon.edu .  APEX uses TAU to generate profiles for post-mortem performance analysis. See  the TAU use case  for an example.  -DTAU_ROOT= \n  path to TAU, or set the TAU_ROOT environment variable before running cmake.  -DTAU_ARCH= \n  the TAU architecture, like x86_64, craycnl, mic_linux, bgq, etc.  -DTAU_OPTIONS= \n  a TAU configuration with thread support, like -pthread or -icpc-pthread.  -DUSE_RCR= \n  TRUE or  FALSE .  RCR (Resource Centric Reflection) is a library for system monitoring of resources that require root access.  For more information, see  http://www.renci.org/wp-content/pub/techreports/TR-10-01.pdf .  APEX uses RCR to access 'uncore' counters and system health information such as power and energy counters.  -DRCR_ROOT= \n  the path to RCR, or set the RCR_ROOT environment variable.  -DUSE_TCMALLOC= \n  TRUE or  FALSE .  TCMalloc is a heap management library distributed as part of Google perftools. For more information, see  https://github.com/gperftools/gperftools .  TCMalloc provides faster memory performance in multithreaded environments.  -DGPERFTOOLS_ROOT= \n  path to gperftools (TCMalloc), or set the GPERFTOOLS_ROOT environment variable before running cmake.  -DUSE_JEMALLOC= \n  TRUE or  FALSE .  JEMalloc is a heap management library.  For more information, see  http://www.canonware.com/jemalloc/ .  JEMalloc provides faster memory performance in multithreaded environments.  -DJEMALLOC_ROOT= \n  path to JEMalloc, or set the JEMALLOC_ROOT environment variable before running cmake.  -DUSE_PAPI= \n  TRUE or  FALSE .  PAPI (Performance Application Programming Interface) provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors.  For more information, see  http://icl.cs.utk.edu/papi/ .  APEX uses PAPI to optionally collect hardware counters for timed events.  -DPAPI_ROOT= \n  some path to PAPI, or set the PAPI_ROOT environment variable before running cmake. See  the PAPI use case  for an example.  -DUSE_LM_SENSORS= \n  TRUE or  FALSE . Lm_sensors (Linux Monitoring Sensors) is a library for monitoring hardware temperatures and fan speeds. For more information, see  https://en.wikipedia.org/wiki/Lm_sensors .  APEX uses lm_sensors to monitor hardware, where available.  -DBUILD_EXAMPLES= \n  TRUE or  FALSE . Whether or not to build the application examples in APEX.  -DBUILD_TESTS= \n   TRUE  or FALSE. Whether or not to build the APEX unit tests.  -DCMAKE_C_COMPILER= \n   gcc  -DCMAKE_CXX_COMPILER= \n   g++  -DCMAKE_BUILD_TYPE= \n  Release,  Debug , RelWithDebInfo. Unfortunately, the cmake default (when not specified) is Debug. For faster performance, configure APEX to build RelWithDebInfo or Release.  -DBUILD_SHARED_LIBS= \n  TRUE or FALSE  -DUSE_MPI= \n  TRUE or  FALSE . Whether to build MPI global support and related examples.  -DMPI_C_INCLUDE_PATH= \n  path to MPI headers  -DMPI_CXX_INCLUDE_PATH= \n  path to MPI headers  -DMPI_C_LIBRARIES= \n  paths to MPI libraries, library names  -DMPI_CXX_LIBRARIES= \n  paths to MPI libraries, library names  -DMPI_C_COMPILER= \n  mpicc  -DMPI_CXX_COMPILER= \n  mpicxx", 
            "title": "Other CMake settings, depending on your needs/wants"
        }, 
        {
            "location": "/usage/", 
            "text": "Supported Runtime Systems\n\n\nHPX (Louisiana State University)\n\n\nHPX (High Performance ParalleX) is the original implementation of the ParalleX model. Developed and maintained by the Ste||ar Group at Louisiana State University, HPX is implemented in C++. For more information, see \nhttp://stellar.cct.lsu.edu/tag/hpx/\n.  For a tutorial on HPX with APEX (presented at SC'15, Austin TX) see \nhttps://github.com/khuck/SC15_APEX_tutorial\n.\n\n\nAPEX is configured and built as part of HPX. In fact, you don't even need to donwload it separately - it will be automatically checked out from Github as part of the HPX Cmake configuration.  However, you do need to pass the correct Cmake options to the HPX configuration step.\n\n\nUsing TAU to profile or trace HPX\n\n\nIf you want to use TAU to collect profiles or traces of HPX applications, you \nwill\n need to download and configure TAU first.  The following instructions will include the TAU options, so please see \nAPEX with TAU\n for instructions on configuring TAU for use with APEX.  For this example, we assume TAU was configured with \"./configure -mpi -pthread\" on an x86_64 Linux machine. \n\n\nConfiguring HPX with APEX\n\n\nAfter TAU is configured and built, we are ready to configure and build HPX. Configure HPX as usual, but add the following options:\n\n\nmkdir build\ncd build\n\n# The source code is located in $HOME/src/hpx\ncmake \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DCMAKE_INSTALL_PREFIX=. \\\n-DHPX_WITH_PARCELPORT_MPI=TRUE \\\n-DHPX_WITH_APEX=TRUE \\\n-DAPEX_WITH_ACTIVEHARMONY=TRUE \\\n-DHPX_WITH_TAU=TRUE -DTAU_ROOT=$HOME/src/tau2 \\\n-DTAU_ARCH=x86_64 -DTAU_OPTIONS=-mpi-pthread \\\n-DHPX_WITH_MALLOC=jemalloc \\\n$HOME/src/hpx\n\nmake -j5 core\nmake -j5 components\nmake -j3 examples\n\n\n\n\nTo confirm that HPX was configured and built with APEX correctly, run the simple HPX example:\n\n\nexport APEX_SCREEN_OUTPUT=1\n./build/bin/fibonacci\n\n\n\n\nWhich should give output similar to this:\n\n\nparquet-7a70deb-release\nBuilt on: 12:06:08 Jan  5 2016\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nfibonacci(10) == 55\nelapsed time: 0.00595707 [s]\nInfo: 1 items remaining on on the profiler_listener queue...done.\nCPU is 2.66024e+09 Hz.\nElapsed time: 0.122906\nCores detected: 8\nWorker Threads observed: 1\nAvailable CPU time: 0.122906\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n              APEX MAIN THREAD :        1    --n/a--   1.22e-01    --n/a--   1.22e-01    --n/a--     99.631\nbroadcast_call_shutdown_fun... :        2    --n/a--   2.59e-05    --n/a--   5.18e-05    --n/a--      0.042\nbroadcast_call_startup_func... :        2    --n/a--   2.36e-05    --n/a--   4.72e-05    --n/a--      0.038\ncall_shutdown_functions_action :        2    --n/a--   2.29e-04    --n/a--   4.58e-04    --n/a--      0.373\n call_startup_functions_action :        2    --n/a--   8.01e-05    --n/a--   1.60e-04    --n/a--      0.130\n              fibonacci_action :      177    --n/a--   1.28e-05    --n/a--   2.26e-03    --n/a--      1.841\n                      hpx_main :        1    --n/a--   4.13e-04    --n/a--   4.13e-04    --n/a--      0.336\n        load_components_action :        2    --n/a--   1.96e-03    --n/a--   3.92e-03    --n/a--      3.192\n                      pre_main :        1    --n/a--   1.39e-03    --n/a--   1.39e-03    --n/a--      1.135\nprimary_namespace_bulk_serv... :       24    --n/a--   2.35e-05    --n/a--   5.65e-04    --n/a--      0.459\nprimary_namespace_service_a... :        4    --n/a--   1.02e-05    --n/a--   4.08e-05    --n/a--      0.033\n                    run_helper :        1    --n/a--   2.80e-04    --n/a--   2.80e-04    --n/a--      0.228\nsymbol_namespace_service_ac... :        4    --n/a--   1.73e-05    --n/a--   6.93e-05    --n/a--      0.056\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------\n\n\n\n\nTo enable TAU profiling, set the APEX_TAU environment variable to 1.  We will also set some other TAU environment varaibles and re-run the program:\n\n\nexport APEX_TAU=1\nexport TAU_PROFILE_FORMAT=merged\n./build/bin/fibonacci\n\n\n\n\nThe \"merged\" profile setting will create a single file (tauprofile.xml) for the whole application, rather than a profile.* file for each thread.\n\n\nAfter execution, there is a TAU profile file called \"tauprofile.xml\".  To view the results of the profiling, run the ParaProf application on the profile (assuming the TAU utilities are in your path):\n\n\nparaprof tauprofile.xml\n\n\n\n\nFor more information on using TAU with APEX, see \nAPEX with TAU\n.\n\n\nHPX-5 (Indiana University)\n\n\nHPX-5 (High Performance ParalleX) is a second implementation of the ParalleX model. Developed and maintained by the CREST Group at Indiana University, HPX-5 is implemented in C.  For more information, see \nhttps://hpx.crest.iu.edu\n.\n\n\nConfiguring HPX-5 with APEX\n\n\nAPEX is built as a pre-requisite dependency of HPX-5. So, before configuring and building HPX-5, configure and build APEX as a standalone library.  In addition to the usual required options for CMake, we will also include the options to include Active Harmony (for policies), TAU (for performance analysis - see \nAPEX with TAU\n for instructions on configuring TAU) and Binutils support, because the HPX-5 instrumentation uses function addresses to identify timers rather than strings.  To include Binutils, we can choose one of:\n\n\n\n\nuse a system-installed binutils by specifying \n-DUSE_BFD=TRUE\n\n\nuse a custom build of Binutils by specifying \n-DUSE_BFD=TRUE -DBFD_ROOT=\npath-to-binutils-installation\n\n\nhave APEX download and build Binutils automatically by specifying \n-DBUILD_BFD=TRUE\n.\n\n\n\n\nNote:\n \nHPX-5 uses JEMalloc, TBB Malloc or DLMalloc, so \nDO NOT\n configure APEX with either TCMalloc or JEMalloc.\n\n\nFor example, assume TAU is installed in /usr/local/tau/2.25 and we will have CMake download and build Binutils and Active Harmony, and we want to install APEX to /usr/local/apex/0.5.  To configure, build and install APEX in the main source directory (your paths may vary):\n\n\ncd $HOME/src\nwget https://github.com/khuck/xpress-apex/archive/v0.5.tar.gz\ntar -xvzf v0.5.tar.gz\ncd xpress-apex-0.5\nmkdir build\ncd build\ncmake \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_OPTIONS=-papi-pthread -DTAU_ARCH=x86_64 \\\n-DBUILD_BFD=TRUE -DCMAKE_INSTALL_PREFIX=/usr/local/xpress-apex/0.5 -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\nmake\nmake test # optional\nmake doc # optional\nmake install\n\n\n\n\nKeep in mind that APEX will automatically download, configure and build Active Harmony as part of the build process, unless you pass \n-DUSE_ACTIVEHARMONY=FALSE\n to the cmake command.  After the build is complete, add the package configuration path to your PKG_CONFIG_PATH environment variable (HPX-5 uses autotools for configuration so it will find APEX using the utility pkg-config):\n\n\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.5/lib/pkgconfig\n\n\n\n\nTo confirm the PKG_CONFIG_PATH variable is set correctly, try executing the pkg-config command:\n\n\npkg-config --libs apex\n\n\n\n\nWhich should give the following output (or something similar):\n\n\n-L/usr/local/xpress-apex/0.5/lib -L/usr/local/tau/2.25/x86_64/lib -L/usr/local/xpress-apex/0.5/lib -lapex -lpthread -lTAUsh-papi-pthread -lharmony -lbfd -liberty -lz -lm -Wl,-rpath,/usr/local/tau/2.25/x86_64/lib,-rpath,/usr/local/xpress-apex/0.5/lib -lstdc++\n\n\n\n\nOnce APEX is installed, you can configure and build HPX-5 with APEX.  To include APEX in the HPX-5 configuration, include the --with-apex=yes option when calling configure.  Assuming you have downloaded HPX-5 v.3.0, you would do the following:\n\n\n# go to the HPX source directory\ncd HPX_Release_v3.0.0/hpx\n# If you haven't already set the pkgconfig path, do so now...\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.5/lib/pkgconfig\n# configure\n./bootstrap\n./configure --enable-testsuite --prefix=/home/khuck/src/hpx-iu/hpx-install --with-apex=yes\n# build!\nmake -j8\n# install!\nmake install\n\n\n\n\nTo confirm that HPX-5 was configured and built with APEX correctly, run the simple APEX example:\n\n\nexport APEX_SCREEN_OUTPUT=1\n./tests/unit/apex\n\n\n\n\nWhich should give output similar to this:\n\n\nv0.1-5e4ac87-master\nBuilt on: 13:23:34 Dec 17 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n\nMissing fib number. Using 10.\nfib(10)=55\nseconds: 0.0005629\nlocalities: 1\nthreads/locality: 8\nInfo: 34 items remaining on on the profiler_listener queue...done.\nCPU is 2.66036e+09 Hz.\nElapsed time: 0.0364015\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 0.291212\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_fib_main_action [{/home/kh... :        1    --n/a--   4.52e-04    --n/a--   4.52e-04    --n/a--      0.155\n_fib_action [{/home/khuck/s... :      177    --n/a--   4.39e-06    --n/a--   7.77e-04    --n/a--      0.267\n_locality_stop_handler [{/h... :        1    --n/a--   1.21e-05    --n/a--   1.21e-05    --n/a--      0.004\n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   2.90e-01    --n/a--     99.574\n------------------------------------------------------------------------------------------------------------\n\n\n\n\nBuilding HPX-5 applications with APEX\n\n\nAPEX will automatically be included in the link when HPX-5 applciations are built. To build an example, go to the hpx-apps directory and build the LULESH parcels example:\n\n\ncd hpx-apps/lulesh/parcels\n# assuming HPX-5 is installed in /usr/local/hpx/3.0, set the pkgconfig path\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/hpx/3.0/lib/pkgconfig\n# configure \n./bootstrap\n./configure\n# make!\nmake\n\n\n\n\nThen, to run the LULESH example:\n\n\nexport APEX_SCREEN_OUTPUT=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8\n\n\n\n\nShould give the following output (or similar):\n\n\nv0.1-907c977-master\nBuilt on: 09:50:08 Dec 23 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n Number of domains: 8 nx: 24 maxcycles: 100 core-major ordering: 1\n\n\nSTART_LOG\nPROGNAME: lulesh-parcels\n\nElapsed time = 1.255209e+01\n\nRun completed:  \n  Problem size = 24 \n  Iteration count = 100 \n  Final Origin Energy = 4.739209e+06\n  Testing plane 0 of energy array:\n  MaxAbsDiff   = 9.313226e-10\n  TotalAbsDiff = 2.841568e-09\n  MaxRelDiff   = 2.946213e-12\n\nEND_LOG\n\ntime_in_SBN3 = 4.570989e-01\ntime_in_PosVel = 2.182410e-01\ntime_in_MonoQ = 4.889381e+00\n Elapsed: 12599.4\nCPU is 2.66028e+09 Hz.\nElapsed time: 12.6192\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 100.953\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_advanceDomain_action [{/ho... :        8    --n/a--   1.17e+01    --n/a--   9.34e+01    --n/a--     92.506\n_initDomain_action [{/home/... :        8    --n/a--   2.04e-02    --n/a--   1.63e-01    --n/a--      0.162\n_finiDomain_action [{/home/... :        8    --n/a--   2.81e-03    --n/a--   2.25e-02    --n/a--      0.022\n_main_action [{/home/khuck/... :        1    --n/a--   4.73e-03    --n/a--   4.73e-03    --n/a--      0.005\n_SBN1_result_action [{/home... :       56    --n/a--   1.42e-03    --n/a--   7.93e-02    --n/a--      0.079\n_SBN1_sends_action [{/home/... :       56    --n/a--   1.87e-04    --n/a--   1.05e-02    --n/a--      0.010\n_SBN3_result_action [{/home... :     5600    --n/a--   1.33e-04    --n/a--   7.45e-01    --n/a--      0.738\n_SBN3_sends_action [{/home/... :     5600    --n/a--   9.05e-05    --n/a--   5.07e-01    --n/a--      0.502\n_PosVel_result_action [{/ho... :     2800    --n/a--   1.61e-04    --n/a--   4.50e-01    --n/a--      0.445\n_PosVel_sends_action [{/hom... :     2800    --n/a--   1.43e-04    --n/a--   4.00e-01    --n/a--      0.396\n_MonoQ_result_action [{/hom... :     2400    --n/a--   1.03e-04    --n/a--   2.47e-01    --n/a--      0.245\n_MonoQ_sends_action [{/home... :     2400    --n/a--   1.79e-04    --n/a--   4.29e-01    --n/a--      0.425\n_locality_stop_handler [{/h... :        1    --n/a--   2.45e-04    --n/a--   2.45e-04    --n/a--      0.000\n_allreduce_init_handler [{/... :        2    --n/a--   5.49e-04    --n/a--   1.10e-03    --n/a--      0.001\n_allreduce_fini_handler [{/... :        2    --n/a--   2.44e-04    --n/a--   4.89e-04    --n/a--      0.000\n_allreduce_add_handler [{/h... :        9    --n/a--   6.74e-05    --n/a--   6.07e-04    --n/a--      0.001\n_allreduce_remove_handler [... :        9    --n/a--   4.31e-05    --n/a--   3.88e-04    --n/a--      0.000\n_allreduce_join_handler [{/... :       99    --n/a--   4.90e-05    --n/a--   4.86e-03    --n/a--      0.005\n_allreduce_bcast_handler [{... :       99    --n/a--   2.75e-05    --n/a--   2.72e-03    --n/a--      0.003\n                   CPU Guest % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                     CPU IRQ % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       12      0.000      0.789      8.429      9.464      2.305    --n/a-- \n                    CPU Nice % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       12     21.000     22.387     24.286    268.643      0.941    --n/a-- \n                    CPU User % :       12     77.500     80.426     89.714    965.107      4.315    --n/a-- \n                CPU soft IRQ % :       12      0.000      0.010      0.125      0.125      0.035    --n/a-- \n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   4.50e+00    --n/a--      4.455\n------------------------------------------------------------------------------------------------------------\n\n\n\n\nTo enable TAU profiling, set the APEX_TAU environment variable to 1.  We will also set some other TAU environment varaibles and re-run the program:\n\n\nexport APEX_TAU=1\nexport TAU_PROFILE_FORMAT=merged\nexport TAU_SAMPLING=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8\n\n\n\n\nThe \"merged\" profile setting will create a single file (tauprofile.xml) for the whole application, rather than a profile.* file for each thread. The sampling flag will enable periodic interruption of the application to get a more detailed profile.\n\n\nAfter execution, there is a TAU profile file called \"tauprofile.xml\".  To view the results of the profiling, run the ParaProf application on the profile (assuming the TAU utilities are in your path):\n\n\nparaprof tauprofile.xml\n\n\n\n\nWhich should result in a profile like the following:\n\n\n\n\nAbove: ParaProf main profiler window showing all threads of execution.\n\n\n\n\nAbove: ParaProf main profiler window showing one thread of execution.\n\n\n\n\nAbove: ParaProf main profiler window showing one thread of execution, in a callgraph view.\n\n\nFor more information on using TAU with APEX, see \nAPEX with TAU\n.\n\n\nOpenMP\n\n\nThe OpenMP API supports multi-platform shared-memory parallel programming in C/C++ and Fortran. The OpenMP API defines a portable, scalable model with a simple and flexible interface for developing parallel applications on platforms from the desktop to the supercomputer.  For more information, see \nhttp://openmp.org/\n.\n\n\nRunning OpenMP applications with APEX\n\n\n...Coming soon!", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#supported-runtime-systems", 
            "text": "", 
            "title": "Supported Runtime Systems"
        }, 
        {
            "location": "/usage/#hpx-louisiana-state-university", 
            "text": "HPX (High Performance ParalleX) is the original implementation of the ParalleX model. Developed and maintained by the Ste||ar Group at Louisiana State University, HPX is implemented in C++. For more information, see  http://stellar.cct.lsu.edu/tag/hpx/ .  For a tutorial on HPX with APEX (presented at SC'15, Austin TX) see  https://github.com/khuck/SC15_APEX_tutorial .  APEX is configured and built as part of HPX. In fact, you don't even need to donwload it separately - it will be automatically checked out from Github as part of the HPX Cmake configuration.  However, you do need to pass the correct Cmake options to the HPX configuration step.  Using TAU to profile or trace HPX  If you want to use TAU to collect profiles or traces of HPX applications, you  will  need to download and configure TAU first.  The following instructions will include the TAU options, so please see  APEX with TAU  for instructions on configuring TAU for use with APEX.  For this example, we assume TAU was configured with \"./configure -mpi -pthread\" on an x86_64 Linux machine.   Configuring HPX with APEX  After TAU is configured and built, we are ready to configure and build HPX. Configure HPX as usual, but add the following options:  mkdir build\ncd build\n\n# The source code is located in $HOME/src/hpx\ncmake \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DCMAKE_INSTALL_PREFIX=. \\\n-DHPX_WITH_PARCELPORT_MPI=TRUE \\\n-DHPX_WITH_APEX=TRUE \\\n-DAPEX_WITH_ACTIVEHARMONY=TRUE \\\n-DHPX_WITH_TAU=TRUE -DTAU_ROOT=$HOME/src/tau2 \\\n-DTAU_ARCH=x86_64 -DTAU_OPTIONS=-mpi-pthread \\\n-DHPX_WITH_MALLOC=jemalloc \\\n$HOME/src/hpx\n\nmake -j5 core\nmake -j5 components\nmake -j3 examples  To confirm that HPX was configured and built with APEX correctly, run the simple HPX example:  export APEX_SCREEN_OUTPUT=1\n./build/bin/fibonacci  Which should give output similar to this:  parquet-7a70deb-release\nBuilt on: 12:06:08 Jan  5 2016\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nfibonacci(10) == 55\nelapsed time: 0.00595707 [s]\nInfo: 1 items remaining on on the profiler_listener queue...done.\nCPU is 2.66024e+09 Hz.\nElapsed time: 0.122906\nCores detected: 8\nWorker Threads observed: 1\nAvailable CPU time: 0.122906\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n              APEX MAIN THREAD :        1    --n/a--   1.22e-01    --n/a--   1.22e-01    --n/a--     99.631\nbroadcast_call_shutdown_fun... :        2    --n/a--   2.59e-05    --n/a--   5.18e-05    --n/a--      0.042\nbroadcast_call_startup_func... :        2    --n/a--   2.36e-05    --n/a--   4.72e-05    --n/a--      0.038\ncall_shutdown_functions_action :        2    --n/a--   2.29e-04    --n/a--   4.58e-04    --n/a--      0.373\n call_startup_functions_action :        2    --n/a--   8.01e-05    --n/a--   1.60e-04    --n/a--      0.130\n              fibonacci_action :      177    --n/a--   1.28e-05    --n/a--   2.26e-03    --n/a--      1.841\n                      hpx_main :        1    --n/a--   4.13e-04    --n/a--   4.13e-04    --n/a--      0.336\n        load_components_action :        2    --n/a--   1.96e-03    --n/a--   3.92e-03    --n/a--      3.192\n                      pre_main :        1    --n/a--   1.39e-03    --n/a--   1.39e-03    --n/a--      1.135\nprimary_namespace_bulk_serv... :       24    --n/a--   2.35e-05    --n/a--   5.65e-04    --n/a--      0.459\nprimary_namespace_service_a... :        4    --n/a--   1.02e-05    --n/a--   4.08e-05    --n/a--      0.033\n                    run_helper :        1    --n/a--   2.80e-04    --n/a--   2.80e-04    --n/a--      0.228\nsymbol_namespace_service_ac... :        4    --n/a--   1.73e-05    --n/a--   6.93e-05    --n/a--      0.056\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------  To enable TAU profiling, set the APEX_TAU environment variable to 1.  We will also set some other TAU environment varaibles and re-run the program:  export APEX_TAU=1\nexport TAU_PROFILE_FORMAT=merged\n./build/bin/fibonacci  The \"merged\" profile setting will create a single file (tauprofile.xml) for the whole application, rather than a profile.* file for each thread.  After execution, there is a TAU profile file called \"tauprofile.xml\".  To view the results of the profiling, run the ParaProf application on the profile (assuming the TAU utilities are in your path):  paraprof tauprofile.xml  For more information on using TAU with APEX, see  APEX with TAU .", 
            "title": "HPX (Louisiana State University)"
        }, 
        {
            "location": "/usage/#hpx-5-indiana-university", 
            "text": "HPX-5 (High Performance ParalleX) is a second implementation of the ParalleX model. Developed and maintained by the CREST Group at Indiana University, HPX-5 is implemented in C.  For more information, see  https://hpx.crest.iu.edu .  Configuring HPX-5 with APEX  APEX is built as a pre-requisite dependency of HPX-5. So, before configuring and building HPX-5, configure and build APEX as a standalone library.  In addition to the usual required options for CMake, we will also include the options to include Active Harmony (for policies), TAU (for performance analysis - see  APEX with TAU  for instructions on configuring TAU) and Binutils support, because the HPX-5 instrumentation uses function addresses to identify timers rather than strings.  To include Binutils, we can choose one of:   use a system-installed binutils by specifying  -DUSE_BFD=TRUE  use a custom build of Binutils by specifying  -DUSE_BFD=TRUE -DBFD_ROOT= path-to-binutils-installation  have APEX download and build Binutils automatically by specifying  -DBUILD_BFD=TRUE .   Note:   HPX-5 uses JEMalloc, TBB Malloc or DLMalloc, so  DO NOT  configure APEX with either TCMalloc or JEMalloc.  For example, assume TAU is installed in /usr/local/tau/2.25 and we will have CMake download and build Binutils and Active Harmony, and we want to install APEX to /usr/local/apex/0.5.  To configure, build and install APEX in the main source directory (your paths may vary):  cd $HOME/src\nwget https://github.com/khuck/xpress-apex/archive/v0.5.tar.gz\ntar -xvzf v0.5.tar.gz\ncd xpress-apex-0.5\nmkdir build\ncd build\ncmake \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_OPTIONS=-papi-pthread -DTAU_ARCH=x86_64 \\\n-DBUILD_BFD=TRUE -DCMAKE_INSTALL_PREFIX=/usr/local/xpress-apex/0.5 -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\nmake\nmake test # optional\nmake doc # optional\nmake install  Keep in mind that APEX will automatically download, configure and build Active Harmony as part of the build process, unless you pass  -DUSE_ACTIVEHARMONY=FALSE  to the cmake command.  After the build is complete, add the package configuration path to your PKG_CONFIG_PATH environment variable (HPX-5 uses autotools for configuration so it will find APEX using the utility pkg-config):  export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.5/lib/pkgconfig  To confirm the PKG_CONFIG_PATH variable is set correctly, try executing the pkg-config command:  pkg-config --libs apex  Which should give the following output (or something similar):  -L/usr/local/xpress-apex/0.5/lib -L/usr/local/tau/2.25/x86_64/lib -L/usr/local/xpress-apex/0.5/lib -lapex -lpthread -lTAUsh-papi-pthread -lharmony -lbfd -liberty -lz -lm -Wl,-rpath,/usr/local/tau/2.25/x86_64/lib,-rpath,/usr/local/xpress-apex/0.5/lib -lstdc++  Once APEX is installed, you can configure and build HPX-5 with APEX.  To include APEX in the HPX-5 configuration, include the --with-apex=yes option when calling configure.  Assuming you have downloaded HPX-5 v.3.0, you would do the following:  # go to the HPX source directory\ncd HPX_Release_v3.0.0/hpx\n# If you haven't already set the pkgconfig path, do so now...\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/xpress-apex/0.5/lib/pkgconfig\n# configure\n./bootstrap\n./configure --enable-testsuite --prefix=/home/khuck/src/hpx-iu/hpx-install --with-apex=yes\n# build!\nmake -j8\n# install!\nmake install  To confirm that HPX-5 was configured and built with APEX correctly, run the simple APEX example:  export APEX_SCREEN_OUTPUT=1\n./tests/unit/apex  Which should give output similar to this:  v0.1-5e4ac87-master\nBuilt on: 13:23:34 Dec 17 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n\nMissing fib number. Using 10.\nfib(10)=55\nseconds: 0.0005629\nlocalities: 1\nthreads/locality: 8\nInfo: 34 items remaining on on the profiler_listener queue...done.\nCPU is 2.66036e+09 Hz.\nElapsed time: 0.0364015\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 0.291212\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_fib_main_action [{/home/kh... :        1    --n/a--   4.52e-04    --n/a--   4.52e-04    --n/a--      0.155\n_fib_action [{/home/khuck/s... :      177    --n/a--   4.39e-06    --n/a--   7.77e-04    --n/a--      0.267\n_locality_stop_handler [{/h... :        1    --n/a--   1.21e-05    --n/a--   1.21e-05    --n/a--      0.004\n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   2.90e-01    --n/a--     99.574\n------------------------------------------------------------------------------------------------------------  Building HPX-5 applications with APEX  APEX will automatically be included in the link when HPX-5 applciations are built. To build an example, go to the hpx-apps directory and build the LULESH parcels example:  cd hpx-apps/lulesh/parcels\n# assuming HPX-5 is installed in /usr/local/hpx/3.0, set the pkgconfig path\nexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/hpx/3.0/lib/pkgconfig\n# configure \n./bootstrap\n./configure\n# make!\nmake  Then, to run the LULESH example:  export APEX_SCREEN_OUTPUT=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8  Should give the following output (or similar):  v0.1-907c977-master\nBuilt on: 09:50:08 Dec 23 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 0\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 0\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \n Number of domains: 8 nx: 24 maxcycles: 100 core-major ordering: 1\n\n\nSTART_LOG\nPROGNAME: lulesh-parcels\n\nElapsed time = 1.255209e+01\n\nRun completed:  \n  Problem size = 24 \n  Iteration count = 100 \n  Final Origin Energy = 4.739209e+06\n  Testing plane 0 of energy array:\n  MaxAbsDiff   = 9.313226e-10\n  TotalAbsDiff = 2.841568e-09\n  MaxRelDiff   = 2.946213e-12\n\nEND_LOG\n\ntime_in_SBN3 = 4.570989e-01\ntime_in_PosVel = 2.182410e-01\ntime_in_MonoQ = 4.889381e+00\n Elapsed: 12599.4\nCPU is 2.66028e+09 Hz.\nElapsed time: 12.6192\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 100.953\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n_advanceDomain_action [{/ho... :        8    --n/a--   1.17e+01    --n/a--   9.34e+01    --n/a--     92.506\n_initDomain_action [{/home/... :        8    --n/a--   2.04e-02    --n/a--   1.63e-01    --n/a--      0.162\n_finiDomain_action [{/home/... :        8    --n/a--   2.81e-03    --n/a--   2.25e-02    --n/a--      0.022\n_main_action [{/home/khuck/... :        1    --n/a--   4.73e-03    --n/a--   4.73e-03    --n/a--      0.005\n_SBN1_result_action [{/home... :       56    --n/a--   1.42e-03    --n/a--   7.93e-02    --n/a--      0.079\n_SBN1_sends_action [{/home/... :       56    --n/a--   1.87e-04    --n/a--   1.05e-02    --n/a--      0.010\n_SBN3_result_action [{/home... :     5600    --n/a--   1.33e-04    --n/a--   7.45e-01    --n/a--      0.738\n_SBN3_sends_action [{/home/... :     5600    --n/a--   9.05e-05    --n/a--   5.07e-01    --n/a--      0.502\n_PosVel_result_action [{/ho... :     2800    --n/a--   1.61e-04    --n/a--   4.50e-01    --n/a--      0.445\n_PosVel_sends_action [{/hom... :     2800    --n/a--   1.43e-04    --n/a--   4.00e-01    --n/a--      0.396\n_MonoQ_result_action [{/hom... :     2400    --n/a--   1.03e-04    --n/a--   2.47e-01    --n/a--      0.245\n_MonoQ_sends_action [{/home... :     2400    --n/a--   1.79e-04    --n/a--   4.29e-01    --n/a--      0.425\n_locality_stop_handler [{/h... :        1    --n/a--   2.45e-04    --n/a--   2.45e-04    --n/a--      0.000\n_allreduce_init_handler [{/... :        2    --n/a--   5.49e-04    --n/a--   1.10e-03    --n/a--      0.001\n_allreduce_fini_handler [{/... :        2    --n/a--   2.44e-04    --n/a--   4.89e-04    --n/a--      0.000\n_allreduce_add_handler [{/h... :        9    --n/a--   6.74e-05    --n/a--   6.07e-04    --n/a--      0.001\n_allreduce_remove_handler [... :        9    --n/a--   4.31e-05    --n/a--   3.88e-04    --n/a--      0.000\n_allreduce_join_handler [{/... :       99    --n/a--   4.90e-05    --n/a--   4.86e-03    --n/a--      0.005\n_allreduce_bcast_handler [{... :       99    --n/a--   2.75e-05    --n/a--   2.72e-03    --n/a--      0.003\n                   CPU Guest % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                     CPU IRQ % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       12      0.000      0.789      8.429      9.464      2.305    --n/a-- \n                    CPU Nice % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       12      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       12     21.000     22.387     24.286    268.643      0.941    --n/a-- \n                    CPU User % :       12     77.500     80.426     89.714    965.107      4.315    --n/a-- \n                CPU soft IRQ % :       12      0.000      0.010      0.125      0.125      0.035    --n/a-- \n                 failed steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                          mail :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        spawns :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        stacks :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        steals :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                        yields :        1   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00    --n/a-- \n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   4.50e+00    --n/a--      4.455\n------------------------------------------------------------------------------------------------------------  To enable TAU profiling, set the APEX_TAU environment variable to 1.  We will also set some other TAU environment varaibles and re-run the program:  export APEX_TAU=1\nexport TAU_PROFILE_FORMAT=merged\nexport TAU_SAMPLING=1\n./luleshparcels -n 8 -x 24 -i 100 --hpx-threads=8  The \"merged\" profile setting will create a single file (tauprofile.xml) for the whole application, rather than a profile.* file for each thread. The sampling flag will enable periodic interruption of the application to get a more detailed profile.  After execution, there is a TAU profile file called \"tauprofile.xml\".  To view the results of the profiling, run the ParaProf application on the profile (assuming the TAU utilities are in your path):  paraprof tauprofile.xml  Which should result in a profile like the following:   Above: ParaProf main profiler window showing all threads of execution.   Above: ParaProf main profiler window showing one thread of execution.   Above: ParaProf main profiler window showing one thread of execution, in a callgraph view.  For more information on using TAU with APEX, see  APEX with TAU .", 
            "title": "HPX-5 (Indiana University)"
        }, 
        {
            "location": "/usage/#openmp", 
            "text": "The OpenMP API supports multi-platform shared-memory parallel programming in C/C++ and Fortran. The OpenMP API defines a portable, scalable model with a simple and flexible interface for developing parallel applications on platforms from the desktop to the supercomputer.  For more information, see  http://openmp.org/ .  Running OpenMP applications with APEX  ...Coming soon!", 
            "title": "OpenMP"
        }, 
        {
            "location": "/usecases/", 
            "text": "Before you start\n\n\nAll examples on this page assume you have downloaded, configured and built APEX.  \nSee the Getting Started page\n for instructions on how to do that.\n\n\nSimple example\n\n\nIn the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is a simple matrix multiplication example, \nmatmult\n. \n\n\nTo run the matmult example, simply type 'matmult'.  The output should be something like this:\n\n\nkhuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\n\n\n\n\nNot very interesting, eh? To see what APEX measured, set the APEX_SCREEN_OUTPUT environment variable to 1, and run it again:\n\n\nkhuck@ktau:~/src/xpress-apex/install/bin$ export APEX_SCREEN_OUTPUT=1\nkhuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66013e+09 Hz.\nElapsed time: 0.966516\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.86607\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   1.94e-02    --n/a--   2.33e-01    --n/a--      6.014\n                       compute :        4    --n/a--   6.89e-01    --n/a--   2.76e+00    --n/a--     71.279\n           compute_interchange :        4    --n/a--   1.85e-01    --n/a--   7.38e-01    --n/a--     19.091\n                       do_work :        4    --n/a--   9.43e-01    --n/a--   3.77e+00    --n/a--     97.601\n                    freeMatrix :       12    --n/a--   2.36e-04    --n/a--   2.83e-03    --n/a--      0.073\n                    initialize :       12    --n/a--   3.56e-03    --n/a--   4.27e-02    --n/a--      1.104\n                          main :        1    --n/a--   9.66e-01    --n/a--   9.66e-01    --n/a--     24.983\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------\n\n\n\n\nIn this output, we see the status of all of the environment variables (as read by APEX at initialization), the regular program output, and then a summary from APEX at the end. Because APEX captures timestamps using the low-overhead rdtsc function call (where available), the measurements are done in cycles. APEX estimates the Hz rating of the CPU to convert to seconds for output. APEX reports the elapsed wall-clock time, the number of cores detected, the number of worker threads observed, as well as the total available CPU time (wall-clock times workers).\n\n\nOpenMP example\n\n\nIn the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is the OpenMP implementation of LULESH (for details, \nsee the LLNL explanation of LULESH\n).  When APEX is configured with OpenMP OMPT support (using the -DBUILD_OMPT=TRUE or equivalent CMake configuration settings) it will measure OpenMP events. Executing the LULESH example (with APEX_SCREEN_OUTPUT=1) gives the following output:\n\n\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/lulesh_OpenMP_2.0 \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nRunning problem size 30^3 per domain until completion\nNum processors: 1\nRegistering OMPT events...done.\nNum threads: 8\nTotal number of elements: 27000\n\nTo run other sizes, use -s \ninteger\n.\nTo run a fixed number of iterations, use -i \ninteger\n.\nTo run a more or less balanced region set, use -b \ninteger\n.\nTo change the relative costs of regions, use -c \ninteger\n.\nTo print out progress, use -p\nTo write an output file for VisIt, use -v\nSee help (-h) for more options\n\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcCourant...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcHydroCo...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcMonoton...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcSoundSp...\nAPEX: disabling lightweight timer OpenMP_BARRIER: InitStressT...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVolumeF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcAcceler...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVelocit...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPositio...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcLagrang...\nAPEX: disabling lightweight timer OpenMP_BARRIER: UpdateVolum...\nAPEX: disabling lightweight timer OpenMP_BARRIER: ApplyAccele...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcForceFo...\nRun completed:  \n   Problem size        =  30 \n   MPI tasks           =  1 \n   Iteration count     =  932 \n   Final Origin Energy = 2.025075e+05 \n   Testing Plane 0 of Energy Array on rank 0:\n        MaxAbsDiff   = 6.548362e-11\n        TotalAbsDiff = 8.615093e-10\n        MaxRelDiff   = 1.461140e-12\n\n\nElapsed time         =      55.00 (s)\nGrind time (us/z/c)  =  2.1855548 (per dom)  ( 2.1855548 overall)\nFOM                  =  457.54973 (z/s)\n\nCPU is 2.66013e+09 Hz.\nElapsed time: 55.0085\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 440.068\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                   CPU Guest % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       54      0.000      0.040      0.714      2.143      0.133    --n/a-- \n                     CPU IRQ % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       54      0.857      1.384      4.857     74.714      0.763    --n/a-- \n                    CPU Nice % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       54     15.286     23.339     26.714   1260.286      2.301    --n/a-- \n                    CPU User % :       54     84.143     88.373     97.143   4772.143      2.268    --n/a-- \n                CPU soft IRQ % :       54      0.000      0.026      0.286      1.429      0.068    --n/a-- \nOpenMP_BARRIER: ApplyAccele... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: ApplyMateri... :    14912    --n/a--   3.96e-05    --n/a--   5.91e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcAcceler... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcCourant... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.11e-04    --n/a--   8.27e-01    --n/a--      0.188\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.49e-04    --n/a--   1.11e+00    --n/a--      0.252\nOpenMP_BARRIER: CalcForceFo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcHourgla... :     7456    --n/a--   1.32e-04    --n/a--   9.84e-01    --n/a--      0.224\nOpenMP_BARRIER: CalcHydroCo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcKinemat... :     7456    --n/a--   7.88e-05    --n/a--   5.88e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcLagrang... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcMonoton... :     7456    --n/a--   6.98e-05    --n/a--   5.21e-01    --n/a--      0.118\nOpenMP_BARRIER: CalcMonoton... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPositio... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcSoundSp... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVelocit... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVolumeF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: InitStressT... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   6.66e-05    --n/a--   4.97e-01    --n/a--      0.113\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   1.28e-04    --n/a--   9.54e-01    --n/a--      0.217\nOpenMP_BARRIER: UpdateVolum... : DISABLED (high frequency, short duration)\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   1.09e-04    --n/a--   1.01e-01    --n/a--      0.023\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   2.58e-04    --n/a--   2.40e-01    --n/a--      0.055\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   7.83e-04    --n/a--   7.30e-01    --n/a--      0.166\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   7.72e-05    --n/a--   7.91e-01    --n/a--      0.180\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.29e-05    --n/a--   1.40e+00    --n/a--      0.318\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   5.07e-05    --n/a--   1.65e+00    --n/a--      0.376\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   3.31e-05    --n/a--   1.08e+00    --n/a--      0.245\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.75e-05    --n/a--   1.55e+00    --n/a--      0.352\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.09e-05    --n/a--   1.34e+00    --n/a--      0.303\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   8.10e-03    --n/a--   7.55e+00    --n/a--      1.715\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.51e-03    --n/a--   3.28e+00    --n/a--      0.744\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.34e-04    --n/a--   4.05e-01    --n/a--      0.092\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.27e-03    --n/a--   3.98e+00    --n/a--      0.905\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.72e-05    --n/a--   4.84e-01    --n/a--      0.110\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.68e-03    --n/a--   1.57e+00    --n/a--      0.356\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   2.29e-04    --n/a--   2.13e-01    --n/a--      0.048\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.15e-03    --n/a--   1.07e+00    --n/a--      0.244\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   2.29e-04    --n/a--   2.34e+00    --n/a--      0.533\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.98e-04    --n/a--   4.64e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.26e-05    --n/a--   3.19e+00    --n/a--      0.725\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.20e-05    --n/a--   3.13e+00    --n/a--      0.712\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.52e-05    --n/a--   4.63e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.39e-04    --n/a--   3.16e-01    --n/a--      0.072\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.57e-04    --n/a--   1.47e-01    --n/a--      0.033\nOpenMP_PARALLEL_REGION: Eva... :    32620    --n/a--   1.07e-04    --n/a--   3.50e+00    --n/a--      0.796\nOpenMP_PARALLEL_REGION: Eva... :    10252    --n/a--   2.86e-05    --n/a--   2.93e-01    --n/a--      0.067\nOpenMP_PARALLEL_REGION: Ini... :      932    --n/a--   3.52e-04    --n/a--   3.28e-01    --n/a--      0.074\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   3.14e-03    --n/a--   2.93e+00    --n/a--      0.666\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   2.18e-03    --n/a--   2.03e+00    --n/a--      0.461\nOpenMP_PARALLEL_REGION: Upd... :      932    --n/a--   1.34e-04    --n/a--   1.25e-01    --n/a--      0.028\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   3.87e+02    --n/a--     88.011\n------------------------------------------------------------------------------------------------------------\n\n\n\n\nThere are several lightweight events that APEX elects to ignore. The other events are timed by APEX and reported at exit, along with the /proc/stat data (CPU % counters).\n\n\nWith PAPI\n\n\nWhen APEX is configured with PAPI support (using -DPAPI_ROOT=/path/to/papi and -DUSE_PAPI=TRUE), hardware counter data can also be collected by APEX. To specify hardware counters of interest, use the APEX_PAPI_METRICS environment variable:\n\n\nkhuck@ktau:~/src/xpress-apex$ export APEX_PAPI_METRICS=\nPAPI_TOT_INS PAPI_L2_TCM\n\n\n\n\n\n...and then execute as normal:\n\n\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 1\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : PAPI_TOT_INS PAPI_L2_TCM\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66019e+09 Hz.\nElapsed time: 0.954974\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.81989\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  PAPI_TOT_INS PAPI_L2_TCM\n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   2.21e-02    --n/a--   2.65e-01    --n/a--      6.930   1.62e+06   9.10e+03\n                       compute :        4    --n/a--   6.85e-01    --n/a--   2.74e+00    --n/a--     71.743   4.31e+09   1.71e+06\n           compute_interchange :        4    --n/a--   1.81e-01    --n/a--   7.23e-01    --n/a--     18.922   3.77e+09   8.12e+05\n                       do_work :        4    --n/a--   9.44e-01    --n/a--   3.78e+00    --n/a--     98.851   8.10e+09   2.92e+06\n                    freeMatrix :       12    --n/a--   2.07e-04    --n/a--   2.49e-03    --n/a--      0.065   1.13e+06   6.30e+03\n                    initialize :       12    --n/a--   3.58e-03    --n/a--   4.29e-02    --n/a--      1.124   2.21e+07   3.80e+05\n                          main :        1    --n/a--   9.54e-01    --n/a--   9.54e-01    --n/a--     24.978   2.03e+09   7.66e+05\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------\n\n\n\n\nCSV output\n\n\nWhile APEX is not designed for post-mortem performance analysis, you can export the data that APEX collected.  If you set the APEX_CSV_OUTPUT environment variable to 1, APEX will also dump the timer statistics as a CSV file:\n\n\nkhuck@ktau:~/src/xpress-apex$ cat apex.0.csv \n\ntask\n,\nnum calls\n,\ntotal cycles\n,\ntotal microseconds\n,\nPAPI_TOT_INS\n,\nPAPI_L2_TCM\n\n\nallocateMatrix\n,12,704195504,264717,1615804,9100\n\ncompute\n,4,7290209200,2740489,4306522734,1709040\n\ncompute_interchange\n,4,1922797744,722806,3769652571,812196\n\ndo_work\n,4,10044907856,3776018,8101109302,2922142\n\nfreeMatrix\n,12,6613336,2486,1132717,6301\n\ninitialize\n,12,114177592,42921,22093639,379785\n\nmain\n,1,2538202992,954145,2025172707,766218\n\n\n\n\nWith TAU\n\n\nIf APEX is configured with TAU support, then APEX measurements will be forwarded to TAU and recorded as a TAU profile.  In addition, all other TAU features are supported, including sampling, MPI measurement, I/O measurement, tracing, etc. To configure APEX with TAU, specify the flags -DUSE_TAU, -DTAU_ROOT, -DTAU_ARCH, and -DTAU_OPTIONS. For example, if TAU was configured with \"./configure -pthread\" on an x86_64 Linux machine, the APEX configuration options would be \"-DUSE_TAU=1 -DTAU_ROOT=/path/to/tau -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-pthread\".  If TAU was configured with \"./configure -mpi -pthread\" on an x86_64 Linux machine, the APEX configuration options would be \"-DUSE_TAU=1 -DTAU_ROOT=/path/to/tau -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-mpi-pthread\".\n\n\nHere is a suggested configuration for TAU on x86-Linux to use with APEX (some systems require special flags - please contact the maintaners if you are interested):\n\n\n# download the latest TAU release\nwget http://www.cs.uoregon.edu/research/paracomp/tau/tauprofile/dist/tau_latest.tar.gz\n# expand the tar file\ntar -xvzf tau_latest.tar.gz\ncd tau-2.25\n# configure TAU\n./configure -papi=/usr/local/papi/5.3.2 -pthread -prefix=/usr/local/tau/2.25\n# build\nmake -j install\n# set our path to include the new TAU installation\nexport PATH=$PATH:/usr/local/tau/2.25/x86_64/bin\n\n\n\n\nHere is a suggested configuration for APEX to use the above TAU installation:\n\n\ncd xpress-apex\nmkdir build-tau\ncd build-tau\ncmake -DBUILD_EXAMPLES=TRUE -DBUILD_TESTS=TRUE -DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-papi-pthread \\\n-DBUILD_BFD=TRUE -DBUILD_ACTIVEHARMONY=TRUE -DCMAKE_INSTALL_PREFIX=../install-tau ..\nmake\nmake tests\nmake install\n\n\n\n\nAfter configuring, building and installing TAU and then configuring, building and installing APEX, the TAU profiling is enabled by setting the environment variable \"APEX_TAU=1\".  After executing an example (say 'matmult'), there should be profile.* files in the working directory:\n\n\nkhuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls profile.*\nprofile.0.0.0  profile.0.0.1  profile.0.0.2  profile.0.0.3  profile.0.0.4  profile.0.0.5\n\n\n\n\nIf the TAU analysis utilties are in your path, you can execute \nparaprof\n to view the profiles:\n\n\nkhuck@ktau:~/src/xpress-apex$ paraprof\n\n\n\n\n...which should launch the ParaProf profile viewer/analysis program. The profile should look something like the following (for a complete manual on using ParaProf, see \nthe TAU website\n).\n\n\n\n\n\n\nIf you want to collect a TAU trace, you would enable the appropriate TAU environment variable (TAU_TRACE=1), and then re-run the example.  After the execution, the trace files need to be merged (using tau_treemerge.pl) and then converted (with tau2slog2) to be viewed with the Jumpshot trace viewer (included with TAU):\n\n\nkhuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ export TAU_TRACE=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls *.edf *.trc\nevents.0.edf        tautrace.0.0.1.trc  tautrace.0.0.3.trc  tautrace.0.0.5.trc\ntautrace.0.0.0.trc  tautrace.0.0.2.trc  tautrace.0.0.4.trc\n\n# merge the trace\nkhuck@ktau:~/src/xpress-apex$ tau_treemerge.pl \n/home/khuck/src/tau2/x86_64/bin/tau_merge -m tau.edf -e events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf tautrace.0.0.0.trc tautrace.0.0.1.trc tautrace.0.0.2.trc tautrace.0.0.3.trc tautrace.0.0.4.trc tautrace.0.0.5.trc tau.trc\ntautrace.0.0.0.trc: 34 records read.\ntautrace.0.0.1.trc: 8 records read.\ntautrace.0.0.2.trc: 8 records read.\ntautrace.0.0.3.trc: 30 records read.\ntautrace.0.0.4.trc: 30 records read.\ntautrace.0.0.5.trc: 30 records read.\n\n# convert the trace\nkhuck@ktau:~/src/xpress-apex$ tau2slog2 tau.trc tau.edf -o tau.slog2\n140 records initialized.  Processing.\n2 Records read. 1% converted\n4 Records read. 2% converted\n6 Records read. 4% converted\n8 Records read. 5% converted\n10 Records read. 7% converted\n12 Records read. 8% converted\n14 Records read. 10% converted\n16 Records read. 11% converted\n18 Records read. 12% converted\n20 Records read. 14% converted\n22 Records read. 15% converted\n24 Records read. 17% converted\n26 Records read. 18% converted\n28 Records read. 20% converted\n30 Records read. 21% converted\n32 Records read. 22% converted\n34 Records read. 24% converted\n36 Records read. 25% converted\n38 Records read. 27% converted\n40 Records read. 28% converted\n42 Records read. 30% converted\n44 Records read. 31% converted\n46 Records read. 32% converted\n48 Records read. 34% converted\n50 Records read. 35% converted\n52 Records read. 37% converted\n54 Records read. 38% converted\n56 Records read. 40% converted\n58 Records read. 41% converted\n60 Records read. 42% converted\n62 Records read. 44% converted\n64 Records read. 45% converted\n66 Records read. 47% converted\n68 Records read. 48% converted\n70 Records read. 50% converted\n72 Records read. 51% converted\n74 Records read. 52% converted\n76 Records read. 54% converted\n78 Records read. 55% converted\n80 Records read. 57% converted\n82 Records read. 58% converted\n84 Records read. 60% converted\n86 Records read. 61% converted\n88 Records read. 62% converted\n90 Records read. 64% converted\n92 Records read. 65% converted\n94 Records read. 67% converted\n96 Records read. 68% converted\n98 Records read. 70% converted\n100 Records read. 71% converted\n102 Records read. 72% converted\n104 Records read. 74% converted\n106 Records read. 75% converted\n108 Records read. 77% converted\n110 Records read. 78% converted\n112 Records read. 80% converted\n114 Records read. 81% converted\n116 Records read. 82% converted\n118 Records read. 84% converted\n120 Records read. 85% converted\n122 Records read. 87% converted\n124 Records read. 88% converted\n1521 enters: 0 exits: 0\n126 Records read. 90% converted\n1521 enters: 0 exits: 0\n128 Records read. 91% converted\n130 Records read. 92% converted\n1521 enters: 0 exits: 0\n132 Records read. 94% converted\n1521 enters: 0 exits: 0\n134 Records read. 95% converted\n136 Records read. 97% converted\n1521 enters: 0 exits: 0\n138 Records read. 98% converted\n1521 enters: 0 exits: 0\n140 Records read. 100% converted\nReached end of trace file.\nGetting YMap, Maxnode: 0, Maxthread: 5\n     SLOG-2 Header:\nversion = SLOG 2.0.6\nNumOfChildrenPerNode = 2\nTreeLeafByteSize = 65536\nMaxTreeDepth = 0\nMaxBufferByteSize = 1960\nCategories  is FBinfo(641 @ 2068)\nMethodDefs  is FBinfo(0 @ 0)\nLineIDMaps  is FBinfo(197 @ 2709)\nTreeRoot    is FBinfo(1960 @ 108)\nTreeDir     is FBinfo(38 @ 2906)\nAnnotations is FBinfo(0 @ 0)\nPostamble   is FBinfo(0 @ 0)\n\n1521 enters: 0 exits: 0\n\nNumber of Drawables = 58\ntimeElapsed between 1 \n 2 = 67 msec\ntimeElapsed between 2 \n 3 = 28 msec\n\n# open jumpshot\nkhuck@ktau:~/src/xpress-apex$ jumpshot tau.slog2\n\n\n\n\n\n\n\n\nPolicy Rules and Runtime Adaptation\n\n\n...Coming soon!", 
            "title": "Use Cases"
        }, 
        {
            "location": "/usecases/#before-you-start", 
            "text": "All examples on this page assume you have downloaded, configured and built APEX.   See the Getting Started page  for instructions on how to do that.", 
            "title": "Before you start"
        }, 
        {
            "location": "/usecases/#simple-example", 
            "text": "In the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is a simple matrix multiplication example,  matmult .   To run the matmult example, simply type 'matmult'.  The output should be something like this:  khuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.  Not very interesting, eh? To see what APEX measured, set the APEX_SCREEN_OUTPUT environment variable to 1, and run it again:  khuck@ktau:~/src/xpress-apex/install/bin$ export APEX_SCREEN_OUTPUT=1\nkhuck@ktau:~/src/xpress-apex/install/bin$ ./matmult\nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66013e+09 Hz.\nElapsed time: 0.966516\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.86607\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   1.94e-02    --n/a--   2.33e-01    --n/a--      6.014\n                       compute :        4    --n/a--   6.89e-01    --n/a--   2.76e+00    --n/a--     71.279\n           compute_interchange :        4    --n/a--   1.85e-01    --n/a--   7.38e-01    --n/a--     19.091\n                       do_work :        4    --n/a--   9.43e-01    --n/a--   3.77e+00    --n/a--     97.601\n                    freeMatrix :       12    --n/a--   2.36e-04    --n/a--   2.83e-03    --n/a--      0.073\n                    initialize :       12    --n/a--   3.56e-03    --n/a--   4.27e-02    --n/a--      1.104\n                          main :        1    --n/a--   9.66e-01    --n/a--   9.66e-01    --n/a--     24.983\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------  In this output, we see the status of all of the environment variables (as read by APEX at initialization), the regular program output, and then a summary from APEX at the end. Because APEX captures timestamps using the low-overhead rdtsc function call (where available), the measurements are done in cycles. APEX estimates the Hz rating of the CPU to convert to seconds for output. APEX reports the elapsed wall-clock time, the number of cores detected, the number of worker threads observed, as well as the total available CPU time (wall-clock times workers).", 
            "title": "Simple example"
        }, 
        {
            "location": "/usecases/#openmp-example", 
            "text": "In the APEX installation directory, there is a bin directory. In the bin directory are a number of examples, one of which is the OpenMP implementation of LULESH (for details,  see the LLNL explanation of LULESH ).  When APEX is configured with OpenMP OMPT support (using the -DBUILD_OMPT=TRUE or equivalent CMake configuration settings) it will measure OpenMP events. Executing the LULESH example (with APEX_SCREEN_OUTPUT=1) gives the following output:  khuck@ktau:~/src/xpress-apex$ ./install/bin/lulesh_OpenMP_2.0 \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 0\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : \nRunning problem size 30^3 per domain until completion\nNum processors: 1\nRegistering OMPT events...done.\nNum threads: 8\nTotal number of elements: 27000\n\nTo run other sizes, use -s  integer .\nTo run a fixed number of iterations, use -i  integer .\nTo run a more or less balanced region set, use -b  integer .\nTo change the relative costs of regions, use -c  integer .\nTo print out progress, use -p\nTo write an output file for VisIt, use -v\nSee help (-h) for more options\n\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPressur...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcEnergyF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcCourant...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcHydroCo...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcMonoton...\nAPEX: disabling lightweight timer OpenMP_BARRIER: EvalEOSForE...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcSoundSp...\nAPEX: disabling lightweight timer OpenMP_BARRIER: InitStressT...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVolumeF...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcAcceler...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcVelocit...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcPositio...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcLagrang...\nAPEX: disabling lightweight timer OpenMP_BARRIER: UpdateVolum...\nAPEX: disabling lightweight timer OpenMP_BARRIER: ApplyAccele...\nAPEX: disabling lightweight timer OpenMP_BARRIER: CalcForceFo...\nRun completed:  \n   Problem size        =  30 \n   MPI tasks           =  1 \n   Iteration count     =  932 \n   Final Origin Energy = 2.025075e+05 \n   Testing Plane 0 of Energy Array on rank 0:\n        MaxAbsDiff   = 6.548362e-11\n        TotalAbsDiff = 8.615093e-10\n        MaxRelDiff   = 1.461140e-12\n\n\nElapsed time         =      55.00 (s)\nGrind time (us/z/c)  =  2.1855548 (per dom)  ( 2.1855548 overall)\nFOM                  =  457.54973 (z/s)\n\nCPU is 2.66013e+09 Hz.\nElapsed time: 55.0085\nCores detected: 8\nWorker Threads observed: 8\nAvailable CPU time: 440.068\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  \n------------------------------------------------------------------------------------------------------------\n                   CPU Guest % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                CPU I/O Wait % :       54      0.000      0.040      0.714      2.143      0.133    --n/a-- \n                     CPU IRQ % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                    CPU Idle % :       54      0.857      1.384      4.857     74.714      0.763    --n/a-- \n                    CPU Nice % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                   CPU Steal % :       54      0.000      0.000      0.000      0.000      0.000    --n/a-- \n                  CPU System % :       54     15.286     23.339     26.714   1260.286      2.301    --n/a-- \n                    CPU User % :       54     84.143     88.373     97.143   4772.143      2.268    --n/a-- \n                CPU soft IRQ % :       54      0.000      0.026      0.286      1.429      0.068    --n/a-- \nOpenMP_BARRIER: ApplyAccele... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: ApplyMateri... :    14912    --n/a--   3.96e-05    --n/a--   5.91e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcAcceler... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcCourant... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcEnergyF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.11e-04    --n/a--   8.27e-01    --n/a--      0.188\nOpenMP_BARRIER: CalcFBHourg... :     7456    --n/a--   1.49e-04    --n/a--   1.11e+00    --n/a--      0.252\nOpenMP_BARRIER: CalcForceFo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcHourgla... :     7456    --n/a--   1.32e-04    --n/a--   9.84e-01    --n/a--      0.224\nOpenMP_BARRIER: CalcHydroCo... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcKinemat... :     7456    --n/a--   7.88e-05    --n/a--   5.88e-01    --n/a--      0.134\nOpenMP_BARRIER: CalcLagrang... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcMonoton... :     7456    --n/a--   6.98e-05    --n/a--   5.21e-01    --n/a--      0.118\nOpenMP_BARRIER: CalcMonoton... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPositio... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcPressur... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcSoundSp... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVelocit... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: CalcVolumeF... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: EvalEOSForE... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: InitStressT... : DISABLED (high frequency, short duration)\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   6.66e-05    --n/a--   4.97e-01    --n/a--      0.113\nOpenMP_BARRIER: IntegrateSt... :     7456    --n/a--   1.28e-04    --n/a--   9.54e-01    --n/a--      0.217\nOpenMP_BARRIER: UpdateVolum... : DISABLED (high frequency, short duration)\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   1.09e-04    --n/a--   1.01e-01    --n/a--      0.023\nOpenMP_PARALLEL_REGION: App... :      932    --n/a--   2.58e-04    --n/a--   2.40e-01    --n/a--      0.055\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   7.83e-04    --n/a--   7.30e-01    --n/a--      0.166\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   7.72e-05    --n/a--   7.91e-01    --n/a--      0.180\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.29e-05    --n/a--   1.40e+00    --n/a--      0.318\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   5.07e-05    --n/a--   1.65e+00    --n/a--      0.376\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   3.31e-05    --n/a--   1.08e+00    --n/a--      0.245\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.75e-05    --n/a--   1.55e+00    --n/a--      0.352\nOpenMP_PARALLEL_REGION: Cal... :    32620    --n/a--   4.09e-05    --n/a--   1.34e+00    --n/a--      0.303\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   8.10e-03    --n/a--   7.55e+00    --n/a--      1.715\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.51e-03    --n/a--   3.28e+00    --n/a--      0.744\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.34e-04    --n/a--   4.05e-01    --n/a--      0.092\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.27e-03    --n/a--   3.98e+00    --n/a--      0.905\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.72e-05    --n/a--   4.84e-01    --n/a--      0.110\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.68e-03    --n/a--   1.57e+00    --n/a--      0.356\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   2.29e-04    --n/a--   2.13e-01    --n/a--      0.048\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.15e-03    --n/a--   1.07e+00    --n/a--      0.244\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   2.29e-04    --n/a--   2.34e+00    --n/a--      0.533\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   4.98e-04    --n/a--   4.64e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.26e-05    --n/a--   3.19e+00    --n/a--      0.725\nOpenMP_PARALLEL_REGION: Cal... :    97860    --n/a--   3.20e-05    --n/a--   3.13e+00    --n/a--      0.712\nOpenMP_PARALLEL_REGION: Cal... :    10252    --n/a--   4.52e-05    --n/a--   4.63e-01    --n/a--      0.105\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   3.39e-04    --n/a--   3.16e-01    --n/a--      0.072\nOpenMP_PARALLEL_REGION: Cal... :      932    --n/a--   1.57e-04    --n/a--   1.47e-01    --n/a--      0.033\nOpenMP_PARALLEL_REGION: Eva... :    32620    --n/a--   1.07e-04    --n/a--   3.50e+00    --n/a--      0.796\nOpenMP_PARALLEL_REGION: Eva... :    10252    --n/a--   2.86e-05    --n/a--   2.93e-01    --n/a--      0.067\nOpenMP_PARALLEL_REGION: Ini... :      932    --n/a--   3.52e-04    --n/a--   3.28e-01    --n/a--      0.074\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   3.14e-03    --n/a--   2.93e+00    --n/a--      0.666\nOpenMP_PARALLEL_REGION: Int... :      932    --n/a--   2.18e-03    --n/a--   2.03e+00    --n/a--      0.461\nOpenMP_PARALLEL_REGION: Upd... :      932    --n/a--   1.34e-04    --n/a--   1.25e-01    --n/a--      0.028\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--   3.87e+02    --n/a--     88.011\n------------------------------------------------------------------------------------------------------------  There are several lightweight events that APEX elects to ignore. The other events are timed by APEX and reported at exit, along with the /proc/stat data (CPU % counters).", 
            "title": "OpenMP example"
        }, 
        {
            "location": "/usecases/#with-papi", 
            "text": "When APEX is configured with PAPI support (using -DPAPI_ROOT=/path/to/papi and -DUSE_PAPI=TRUE), hardware counter data can also be collected by APEX. To specify hardware counters of interest, use the APEX_PAPI_METRICS environment variable:  khuck@ktau:~/src/xpress-apex$ export APEX_PAPI_METRICS= PAPI_TOT_INS PAPI_L2_TCM   ...and then execute as normal:  khuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nv0.1-e050e17-master\nBuilt on: 14:38:56 Dec 22 2015\nC++ Language Standard version : 201402\nGCC Compiler version : 5.2.1 20151010\nAPEX_TAU : 1\nAPEX_POLICY : 1\nAPEX_MEASURE_CONCURRENCY : 0\nAPEX_MEASURE_CONCURRENCY_PERIOD : 1000000\nAPEX_SCREEN_OUTPUT : 1\nAPEX_PROFILE_OUTPUT : 0\nAPEX_CSV_OUTPUT : 1\nAPEX_TASKGRAPH_OUTPUT : 0\nAPEX_PROC_CPUINFO : 0\nAPEX_PROC_MEMINFO : 0\nAPEX_PROC_NET_DEV : 0\nAPEX_PROC_SELF_STATUS : 0\nAPEX_PROC_STAT : 1\nAPEX_THROTTLE_CONCURRENCY : 1\nAPEX_THROTTLING_MAX_THREADS : 8\nAPEX_THROTTLING_MIN_THREADS : 1\nAPEX_THROTTLE_ENERGY : 0\nAPEX_THROTTLING_MAX_WATTS : 300\nAPEX_THROTTLING_MIN_WATTS : 150\nAPEX_PTHREAD_WRAPPER_STACK_SIZE : 0\nAPEX_PAPI_METRICS : PAPI_TOT_INS PAPI_L2_TCM\nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nCPU is 2.66019e+09 Hz.\nElapsed time: 0.954974\nCores detected: 8\nWorker Threads observed: 4\nAvailable CPU time: 3.81989\nAction                         :  #calls  |  minimum |    mean  |  maximum |   total  |  stddev  |  % total  PAPI_TOT_INS PAPI_L2_TCM\n------------------------------------------------------------------------------------------------------------\n                allocateMatrix :       12    --n/a--   2.21e-02    --n/a--   2.65e-01    --n/a--      6.930   1.62e+06   9.10e+03\n                       compute :        4    --n/a--   6.85e-01    --n/a--   2.74e+00    --n/a--     71.743   4.31e+09   1.71e+06\n           compute_interchange :        4    --n/a--   1.81e-01    --n/a--   7.23e-01    --n/a--     18.922   3.77e+09   8.12e+05\n                       do_work :        4    --n/a--   9.44e-01    --n/a--   3.78e+00    --n/a--     98.851   8.10e+09   2.92e+06\n                    freeMatrix :       12    --n/a--   2.07e-04    --n/a--   2.49e-03    --n/a--      0.065   1.13e+06   6.30e+03\n                    initialize :       12    --n/a--   3.58e-03    --n/a--   4.29e-02    --n/a--      1.124   2.21e+07   3.80e+05\n                          main :        1    --n/a--   9.54e-01    --n/a--   9.54e-01    --n/a--     24.978   2.03e+09   7.66e+05\n                     APEX Idle :  --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--    --n/a--   \n------------------------------------------------------------------------------------------------------------", 
            "title": "With PAPI"
        }, 
        {
            "location": "/usecases/#csv-output", 
            "text": "While APEX is not designed for post-mortem performance analysis, you can export the data that APEX collected.  If you set the APEX_CSV_OUTPUT environment variable to 1, APEX will also dump the timer statistics as a CSV file:  khuck@ktau:~/src/xpress-apex$ cat apex.0.csv  task , num calls , total cycles , total microseconds , PAPI_TOT_INS , PAPI_L2_TCM  allocateMatrix ,12,704195504,264717,1615804,9100 compute ,4,7290209200,2740489,4306522734,1709040 compute_interchange ,4,1922797744,722806,3769652571,812196 do_work ,4,10044907856,3776018,8101109302,2922142 freeMatrix ,12,6613336,2486,1132717,6301 initialize ,12,114177592,42921,22093639,379785 main ,1,2538202992,954145,2025172707,766218", 
            "title": "CSV output"
        }, 
        {
            "location": "/usecases/#with-tau", 
            "text": "If APEX is configured with TAU support, then APEX measurements will be forwarded to TAU and recorded as a TAU profile.  In addition, all other TAU features are supported, including sampling, MPI measurement, I/O measurement, tracing, etc. To configure APEX with TAU, specify the flags -DUSE_TAU, -DTAU_ROOT, -DTAU_ARCH, and -DTAU_OPTIONS. For example, if TAU was configured with \"./configure -pthread\" on an x86_64 Linux machine, the APEX configuration options would be \"-DUSE_TAU=1 -DTAU_ROOT=/path/to/tau -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-pthread\".  If TAU was configured with \"./configure -mpi -pthread\" on an x86_64 Linux machine, the APEX configuration options would be \"-DUSE_TAU=1 -DTAU_ROOT=/path/to/tau -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-mpi-pthread\".  Here is a suggested configuration for TAU on x86-Linux to use with APEX (some systems require special flags - please contact the maintaners if you are interested):  # download the latest TAU release\nwget http://www.cs.uoregon.edu/research/paracomp/tau/tauprofile/dist/tau_latest.tar.gz\n# expand the tar file\ntar -xvzf tau_latest.tar.gz\ncd tau-2.25\n# configure TAU\n./configure -papi=/usr/local/papi/5.3.2 -pthread -prefix=/usr/local/tau/2.25\n# build\nmake -j install\n# set our path to include the new TAU installation\nexport PATH=$PATH:/usr/local/tau/2.25/x86_64/bin  Here is a suggested configuration for APEX to use the above TAU installation:  cd xpress-apex\nmkdir build-tau\ncd build-tau\ncmake -DBUILD_EXAMPLES=TRUE -DBUILD_TESTS=TRUE -DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DUSE_TAU=TRUE -DTAU_ROOT=/usr/local/tau/2.25 -DTAU_ARCH=x86_64 -DTAU_OPTIONS=-papi-pthread \\\n-DBUILD_BFD=TRUE -DBUILD_ACTIVEHARMONY=TRUE -DCMAKE_INSTALL_PREFIX=../install-tau ..\nmake\nmake tests\nmake install  After configuring, building and installing TAU and then configuring, building and installing APEX, the TAU profiling is enabled by setting the environment variable \"APEX_TAU=1\".  After executing an example (say 'matmult'), there should be profile.* files in the working directory:  khuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls profile.*\nprofile.0.0.0  profile.0.0.1  profile.0.0.2  profile.0.0.3  profile.0.0.4  profile.0.0.5  If the TAU analysis utilties are in your path, you can execute  paraprof  to view the profiles:  khuck@ktau:~/src/xpress-apex$ paraprof  ...which should launch the ParaProf profile viewer/analysis program. The profile should look something like the following (for a complete manual on using ParaProf, see  the TAU website ).    If you want to collect a TAU trace, you would enable the appropriate TAU environment variable (TAU_TRACE=1), and then re-run the example.  After the execution, the trace files need to be merged (using tau_treemerge.pl) and then converted (with tau2slog2) to be viewed with the Jumpshot trace viewer (included with TAU):  khuck@ktau:~/src/xpress-apex$ export APEX_TAU=1\nkhuck@ktau:~/src/xpress-apex$ export TAU_TRACE=1\nkhuck@ktau:~/src/xpress-apex$ ./install/bin/matmult \nSpawned thread 1...\nSpawned thread 2...\nSpawned thread 3...\nDone.\nkhuck@ktau:~/src/xpress-apex$ ls *.edf *.trc\nevents.0.edf        tautrace.0.0.1.trc  tautrace.0.0.3.trc  tautrace.0.0.5.trc\ntautrace.0.0.0.trc  tautrace.0.0.2.trc  tautrace.0.0.4.trc\n\n# merge the trace\nkhuck@ktau:~/src/xpress-apex$ tau_treemerge.pl \n/home/khuck/src/tau2/x86_64/bin/tau_merge -m tau.edf -e events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf events.0.edf tautrace.0.0.0.trc tautrace.0.0.1.trc tautrace.0.0.2.trc tautrace.0.0.3.trc tautrace.0.0.4.trc tautrace.0.0.5.trc tau.trc\ntautrace.0.0.0.trc: 34 records read.\ntautrace.0.0.1.trc: 8 records read.\ntautrace.0.0.2.trc: 8 records read.\ntautrace.0.0.3.trc: 30 records read.\ntautrace.0.0.4.trc: 30 records read.\ntautrace.0.0.5.trc: 30 records read.\n\n# convert the trace\nkhuck@ktau:~/src/xpress-apex$ tau2slog2 tau.trc tau.edf -o tau.slog2\n140 records initialized.  Processing.\n2 Records read. 1% converted\n4 Records read. 2% converted\n6 Records read. 4% converted\n8 Records read. 5% converted\n10 Records read. 7% converted\n12 Records read. 8% converted\n14 Records read. 10% converted\n16 Records read. 11% converted\n18 Records read. 12% converted\n20 Records read. 14% converted\n22 Records read. 15% converted\n24 Records read. 17% converted\n26 Records read. 18% converted\n28 Records read. 20% converted\n30 Records read. 21% converted\n32 Records read. 22% converted\n34 Records read. 24% converted\n36 Records read. 25% converted\n38 Records read. 27% converted\n40 Records read. 28% converted\n42 Records read. 30% converted\n44 Records read. 31% converted\n46 Records read. 32% converted\n48 Records read. 34% converted\n50 Records read. 35% converted\n52 Records read. 37% converted\n54 Records read. 38% converted\n56 Records read. 40% converted\n58 Records read. 41% converted\n60 Records read. 42% converted\n62 Records read. 44% converted\n64 Records read. 45% converted\n66 Records read. 47% converted\n68 Records read. 48% converted\n70 Records read. 50% converted\n72 Records read. 51% converted\n74 Records read. 52% converted\n76 Records read. 54% converted\n78 Records read. 55% converted\n80 Records read. 57% converted\n82 Records read. 58% converted\n84 Records read. 60% converted\n86 Records read. 61% converted\n88 Records read. 62% converted\n90 Records read. 64% converted\n92 Records read. 65% converted\n94 Records read. 67% converted\n96 Records read. 68% converted\n98 Records read. 70% converted\n100 Records read. 71% converted\n102 Records read. 72% converted\n104 Records read. 74% converted\n106 Records read. 75% converted\n108 Records read. 77% converted\n110 Records read. 78% converted\n112 Records read. 80% converted\n114 Records read. 81% converted\n116 Records read. 82% converted\n118 Records read. 84% converted\n120 Records read. 85% converted\n122 Records read. 87% converted\n124 Records read. 88% converted\n1521 enters: 0 exits: 0\n126 Records read. 90% converted\n1521 enters: 0 exits: 0\n128 Records read. 91% converted\n130 Records read. 92% converted\n1521 enters: 0 exits: 0\n132 Records read. 94% converted\n1521 enters: 0 exits: 0\n134 Records read. 95% converted\n136 Records read. 97% converted\n1521 enters: 0 exits: 0\n138 Records read. 98% converted\n1521 enters: 0 exits: 0\n140 Records read. 100% converted\nReached end of trace file.\nGetting YMap, Maxnode: 0, Maxthread: 5\n     SLOG-2 Header:\nversion = SLOG 2.0.6\nNumOfChildrenPerNode = 2\nTreeLeafByteSize = 65536\nMaxTreeDepth = 0\nMaxBufferByteSize = 1960\nCategories  is FBinfo(641 @ 2068)\nMethodDefs  is FBinfo(0 @ 0)\nLineIDMaps  is FBinfo(197 @ 2709)\nTreeRoot    is FBinfo(1960 @ 108)\nTreeDir     is FBinfo(38 @ 2906)\nAnnotations is FBinfo(0 @ 0)\nPostamble   is FBinfo(0 @ 0)\n\n1521 enters: 0 exits: 0\n\nNumber of Drawables = 58\ntimeElapsed between 1   2 = 67 msec\ntimeElapsed between 2   3 = 28 msec\n\n# open jumpshot\nkhuck@ktau:~/src/xpress-apex$ jumpshot tau.slog2", 
            "title": "With TAU"
        }, 
        {
            "location": "/usecases/#policy-rules-and-runtime-adaptation", 
            "text": "...Coming soon!", 
            "title": "Policy Rules and Runtime Adaptation"
        }, 
        {
            "location": "/environment/", 
            "text": "There are a number of environment variables that control APEX behavior\nat runtime. The variables can be defined in the environment before \napplication execution, or specified in a file called \napex.conf\n in the\ncurrent execution directory.\n\n\n\n\n\n\n\n\nEnvironment Variable\n\n\nDefault Value\n\n\nValid Values\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAPEX_DISABLE\n\n\n0\n\n\n0,1\n\n\nDisable APEX during the application execution\n\n\n\n\n\n\nAPEX_SUSPEND\n\n\n0\n\n\n0,1\n\n\nSuspend APEX timers and counters during the application execution\n\n\n\n\n\n\nAPEX_SCREEN_OUTPUT\n\n\n1\n\n\n0,1\n\n\nOutput APEX options at entry, and performance summary at exit\n\n\n\n\n\n\nAPEX_PROFILE_OUTPUT\n\n\n0\n\n\n0,1\n\n\nOutput TAU profile of performance summary\n\n\n\n\n\n\nAPEX_CSV_OUTPUT\n\n\n0\n\n\n0,1\n\n\nOutput CSV profile of performance summary\n\n\n\n\n\n\nAPEX_TASKGRAPH_OUTPUT\n\n\n0\n\n\n0,1\n\n\nOutput graphviz reduced taskgraph\n\n\n\n\n\n\nAPEX_POLICY\n\n\n1\n\n\n0,1\n\n\nEnable APEX policy listener and execute registered policies\n\n\n\n\n\n\nAPEX_PROC_STAT\n\n\n1\n\n\n0,1\n\n\nPeriodically read data from /proc/stat\n\n\n\n\n\n\nAPEX_PROC_CPUINFO\n\n\n0\n\n\n0,1\n\n\nRead data (once) from /proc/cpuinfo\n\n\n\n\n\n\nAPEX_PROC_MEMINFO\n\n\n0\n\n\n0,1\n\n\nPeriodically read data from /proc/meminfo\n\n\n\n\n\n\nAPEX_PROC_NET_DEV\n\n\n0\n\n\n0,1\n\n\nPeriodically read data from /proc/net/dev\n\n\n\n\n\n\nAPEX_PROC_SELF_STATUS\n\n\n0\n\n\n0,1\n\n\nPeriodically read data from /proc/self/status\n\n\n\n\n\n\nAPEX_MEASURE_CONCURRENCY\n\n\n0\n\n\n0,1\n\n\nPeriodically sample thread activity and output report at exit\n\n\n\n\n\n\nAPEX_MEASURE_CONCURRENCY_PERIOD\n\n\n1000000\n\n\nInteger\n\n\nThread concurrency sampling period, in microseconds\n\n\n\n\n\n\nAPEX_TAU\n\n\n0\n\n\n0,1\n\n\nEnable TAU profiling (if APEX is configured with TAU).\n\n\n\n\n\n\nAPEX_THROTTLE_CONCURRENCY\n\n\n0\n\n\n0,1\n\n\nEnable thread concurrency throttling\n\n\n\n\n\n\nAPEX_THROTTLING_MIN_THREADS\n\n\n1\n\n\n0,1\n\n\nMinimum threads allowed\n\n\n\n\n\n\nAPEX_THROTTLING_MAX_THREADS\n\n\n8\n\n\n0,1\n\n\nMaximum threads allowed\n\n\n\n\n\n\nAPEX_THROTTLE_ENERGY\n\n\n0\n\n\n0,1\n\n\nEnable energy throttling\n\n\n\n\n\n\nAPEX_THROTTLING_MIN_WATTS\n\n\n150\n\n\nInteger\n\n\nMinimum Watt threshold\n\n\n\n\n\n\nAPEX_THROTTLING_MAX_WATTS\n\n\n300\n\n\nInteger\n\n\nMaximum Watt threshold\n\n\n\n\n\n\nAPEX_PTHREAD_WRAPPER_STACK_SIZE\n\n\n0\n\n\n16k-8M\n\n\nWhen wrapping pthread_create, use this size for the stack.\n\n\n\n\n\n\nAPEX_PAPI_METRICS\n\n\nnull\n\n\nspace-delimited string of metric names\n\n\nList of metrics to be measured by APEX when timers are used. Only meaningful if APEX is configured with PAPI support.  Any supported metric from \npapi_avail\n (\nsee PAPI Documentation\n) can be used.\n\n\n\n\n\n\nAPEX_PAPI_SUSPEND\n\n\n0\n\n\n0,1\n\n\nSuspend collection of PAPI metrics for APEX timers during the application execution", 
            "title": "Useful Environment Variables"
        }, 
        {
            "location": "/examples/", 
            "text": "HPX-3 and 1D stencil\n\n\n...coming soon...\n\n\nHPX-5 and LULESH\n\n\n...coming soon...\n\n\nHPX-5 and SSSP\n\n\n...coming soon...\n\n\nHPX-5 and MiniGhost\n\n\n...coming soon...\n\n\nOpenMP and LULESH 2.0\n\n\n...coming soon...\n\n\nOpenMP and NPB 3.2.1\n\n\n...coming soon...\n\n\nMPI applications\n\n\n...coming soon...", 
            "title": "Research Examples"
        }, 
        {
            "location": "/examples/#hpx-3-and-1d-stencil", 
            "text": "...coming soon...", 
            "title": "HPX-3 and 1D stencil"
        }, 
        {
            "location": "/examples/#hpx-5-and-lulesh", 
            "text": "...coming soon...", 
            "title": "HPX-5 and LULESH"
        }, 
        {
            "location": "/examples/#hpx-5-and-sssp", 
            "text": "...coming soon...", 
            "title": "HPX-5 and SSSP"
        }, 
        {
            "location": "/examples/#hpx-5-and-minighost", 
            "text": "...coming soon...", 
            "title": "HPX-5 and MiniGhost"
        }, 
        {
            "location": "/examples/#openmp-and-lulesh-20", 
            "text": "...coming soon...", 
            "title": "OpenMP and LULESH 2.0"
        }, 
        {
            "location": "/examples/#openmp-and-npb-321", 
            "text": "...coming soon...", 
            "title": "OpenMP and NPB 3.2.1"
        }, 
        {
            "location": "/examples/#mpi-applications", 
            "text": "...coming soon...", 
            "title": "MPI applications"
        }, 
        {
            "location": "/spec/", 
            "text": "APEX Specification \n(DRAFT)\n\n\n...to be fully implemented in a future release.  While the following \nspecification is slightly different than the current implementation,\nthe differences are minor. When in doubt, the current implementation\nis documented by Doxygen, and is available here:\n\nhttp://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html\n\n\nhttp://www.nic.uoregon.edu/~khuck/apex_docs/doc/refman.pdf\n\n\n\n\nREAD ME FIRST!\n\n\nThe API specification is provided for users who wish to instrument their\nown applications, or who wish to instrument a runtime. Please note that \nthe \nHPX\n,\n\nHPX-5\n and\n\nOpenMP\n (using the LLVM OpenMP implementation\nwith draft OMPT support) runtimes have already been instrumented,\nand that users typically do not have to make any calls to the APEX API, other\nthan to add application level timers or to write custom policy rules.\n\n\nIntroduction\n\n\nThis page contains the API specification for APEX. The API specification\nprovides a high-level overview of the API and its functionality. The\nimplementation has Doxygen comments inserted, so for full implementation\ndetails, please see the \nAPI Reference Manual\n.  \n\n\nA note about C++\n\n\nThe following specification contains both the C and the the C++ API. Typically,\nthe C++ names use overloading for different argument lists, and will replace\nthe \napex_\n prefix with the \napex::\n namespace. Because both APIs return \nhandles to internal APEX objects, the type definitions of these objects \nuse the C naming convention.\n\n\nTerminology\n\n\nUnfortunately, many terms in Computer Science are overloaded. The following definitions are in use in this document:\n\n\nThread\n: an operating system (OS) thread of execution. For example, Posix threads (pthreads).  \n\n\nTask\n: a scheduled unit of work, such as an OpenMP task or an HPX thread. APEX timers are typically used to measure tasks.\n\n\nC example\n\n\nThe following is a very small C program that uses the APEX API. For more\nexamples, please see the programs in the \nsrc/examples\n and \nsrc/unit_tests/C\n\ndirectories of the APEX source code.\n\n\n#include \nunistd.h\n\n#include \nstdio.h\n\n#include \napex.h\n\n\nint foo(int i) {\n    /* start an APEX timer for the function foo */\n    apex_profiler_handle profiler = apex_start(APEX_FUNCTION_ADDRESS, \nfoo);\n    int j = i * i;\n    /* stop the APEX timer */\n    apex_stop(profiler);\n    return j;\n}\n\nint main (int argc, char** argv) {\n    /* initialize APEX */\n    apex_init(\napex_start unit test\n);\n    /* start a timer, passing in the address of the main function */\n    apex_profiler_handle profiler = apex_start(APEX_FUNCTION_ADDRESS, \nmain);\n    int i,j = 0;\n    for (i = 0 ; i \n 3 ; i++) {\n        j += foo(i);\n    }\n    /* stop the timer */\n    apex_stop(profiler);\n    /* finalize APEX */\n    apex_finalize();\n    /* free all memory allocated by APEX */\n    apex_cleanup();\n    return 0;\n}\n\n\n\n\nC++ example\n\n\nThe following is a slightly more complicated C++ pthread program that uses the\nAPEX API. For more examples, please see the programs in the \nsrc/examples\n and\n\nsrc/unit_tests/C++\n directories of the APEX source code.\n\n\n#include \niostream\n\n#include \npthread.h\n\n#include \nunistd.h\n\n#include \napex_api.hpp\n\n\nvoid* someThread(void* tmp)\n{\n    int* tid = (int*)tmp;\n    char name[32];\n    sprintf(name, \nworker thread %d\n, *tid);\n    /* Register this thread with APEX */\n    apex::register_thread(name);\n    /* Start a timer */\n    apex::profiler* p = apex::start((apex_function_address)\nsomeThread);\n    /* ... */\n    /* do some computation */\n    /* ... */\n    /* stop the timer */\n    apex::stop(p);\n    /* tell APEX that this thread is exiting */\n    apex::exit_thread();\n    return NULL;\n}\n\nint main (int argc, char** argv) {\n    /* initialize APEX */\n    apex::init(\napex::start unit test\n);\n    /* set our node ID */\n    apex::set_node_id(0);\n    /* start a timer */\n    apex::profiler* p = apex::start(\nmain\n);\n    /* Spawn two threads */\n    pthread_t thread[2];\n    int tid = 0;\n    pthread_create(\n(thread[0]), NULL, someThread, \ntid);\n    int tid2 = 1;\n    pthread_create(\n(thread[1]), NULL, someThread, \ntid2);\n    /* wait for the threads to finish */\n    pthread_join(thread[0], NULL);\n    pthread_join(thread[1], NULL);\n    /* stop our main timer */\n    apex::stop(p);\n    /* finalize APEX */\n    apex::finalize();\n    /* free all memory allocated by APEX */\n    apex::cleanup();\n    return 0;\n}\n\n\n\n\nConstants, types and enumerations\n\n\nConstants\n\n\n/** A null pointer representing an APEX profiler handle.\n * Used when a null APEX profile handle is to be passed in to\n * apex::stop when the profiler object was not retained locally.\n */\n#define APEX_NULL_PROFILER_HANDLE (apex_profiler_handle)(NULL) // for comparisons\n\n#define APEX_MAX_EVENTS 128 /*!\n The maximum number of event types. Allows for ~20 custom events. */\n\n#define APEX_NULL_FUNCTION_ADDRESS 0L // for comparisons\n\n\n\n\nPre-defined types\n\n\n/** The address of a C++ object in APEX.\n * Not useful for the caller that gets it back, but required\n * for stopping the timer later.\n */\ntypedef uintptr_t apex_profiler_handle; // address of internal C++ object\n\n/** Not useful for the caller that gets it back, but required\n * for deregistering policies after registration.\n */\ntypedef uintptr_t apex_policy_handle; // address of internal C++ object\n\n/** Rather than use void pointers everywhere, be explicit about\n * what the functions are expecting.\n */\ntypedef uintptr_t apex_function_address; // generic function pointer\n\n\n\n\nEnumerations\n\n\n/**\n * Typedef for enumerating the different timer types\n */\ntypedef enum _apex_profiler_type {\n    APEX_FUNCTION_ADDRESS = 0, /*!\n The ID is a function (or instruction) address */\n    APEX_NAME_STRING,          /*!\n The ID is a character string */\n    APEX_FUNCTOR               /*!\n C++ Object with the () operator defined */\n} apex_profiler_type;\n\n/**\n * Typedef for enumerating the different event types\n */\ntypedef enum _event_type {\n  APEX_INVALID_EVENT = -1,\n  APEX_STARTUP = 0,        /*!\n APEX is initialized */\n  APEX_SHUTDOWN,       /*!\n APEX is terminated */\n  APEX_NEW_NODE,       /*!\n APEX has registered a new process ID */\n  APEX_NEW_THREAD,     /*!\n APEX has registered a new OS thread */\n  APEX_EXIT_THREAD,    /*!\n APEX has exited an OS thread */\n  APEX_START_EVENT,    /*!\n APEX has processed a timer start event */\n  APEX_RESUME_EVENT,   /*!\n APEX has processed a timer resume event (the number\n                           of calls is not incremented) */\n  APEX_STOP_EVENT,     /*!\n APEX has processed a timer stop event */\n  APEX_YIELD_EVENT,    /*!\n APEX has processed a timer yield event */\n  APEX_SAMPLE_VALUE,   /*!\n APEX has processed a sampled value */\n  APEX_PERIODIC,       /*!\n APEX has processed a periodic timer */\n  APEX_CUSTOM_EVENT_1,   /*!\n APEX has processed a custom event - useful for large\n                           granularity application control events */\n  APEX_CUSTOM_EVENT_2, // these are just here for padding, and so we can\n  APEX_CUSTOM_EVENT_3, // test with them.\n  APEX_CUSTOM_EVENT_4,\n  APEX_CUSTOM_EVENT_5,\n  APEX_CUSTOM_EVENT_6,\n  APEX_CUSTOM_EVENT_7,\n  APEX_CUSTOM_EVENT_8,\n  APEX_UNUSED_EVENT = APEX_MAX_EVENTS // can't have more custom events than this\n} apex_event_type;\n\n/** \n * Typedef for enumerating the OS thread states. \n */\ntypedef enum _thread_state {\n    APEX_IDLE,          /*!\n Thread is idle */\n    APEX_BUSY,          /*!\n Thread is working */\n    APEX_THROTTLED,     /*!\n Thread is throttled (sleeping) */\n    APEX_WAITING,       /*!\n Thread is waiting for a resource */\n    APEX_BLOCKED        /*!\n Thread is otherwise blocked */\n} apex_thread_state;\n\n/**\n * Typedef for enumerating the different optimization strategies\n * for throttling.\n */\ntypedef enum {APEX_MAXIMIZE_THROUGHPUT,   /*!\n maximize the number of calls to a\n                                              timer/counter */\n              APEX_MAXIMIZE_ACCUMULATED,  /*!\n maximize the accumulated value of\n                                              a timer/counter */\n              APEX_MINIMIZE_ACCUMULATED   /*!\n minimize the accumulated value of\n                                              a timer/counter */\n} apex_optimization_criteria_t;\n\n/**\n * Typedef for enumerating the different optimization methods\n * for throttling.\n */\ntypedef enum {APEX_SIMPLE_HYSTERESIS,      /*!\n optimize using sliding window of\n                                               historical observations. A running\n                                               average of the most recent N observations\n                                               are used as the measurement. */\n              APEX_DISCRETE_HILL_CLIMBING, /*!\n Use a discrete hill climbing algorithm\n                                               for optimization */\n              APEX_ACTIVE_HARMONY          /*!\n Use Active Harmony for optimization. */\n} apex_optimization_method_t;\n\n/** The type of a profiler object\n * \n */\ntypedef enum _profile_type {\n  APEX_TIMER,        /*!\n This profile is a instrumented timer */\n  APEX_COUNTER       /*!\n This profile is a sampled counter */\n} apex_profile_type;\n\n\n\n\n\n\nData structures and classes\n\n\n/** \n * The APEX context when an event occurs. This context will be passed to \n * any policies registered for this event.\n */\ntypedef struct _context {\n    apex_event_type event_type;        /*!\n The type of the event currently\n                                           processing */\n    apex_policy_handle* policy_handle; /*!\n The policy handle for the current\n                                           policy function */\n    void * data;  /*!\n Data associated with the event, such as the custom_data\n                       for a custom_event */\n} apex_context;\n\n/**\n * The profile object for a timer in APEX. \n * Returned by the apex_get_profile() call.\n */\ntypedef struct _profile {\n    double calls;         /*!\n Number of times a timer was called, or the number\n                              of samples collected for a counter */\n    double accumulated;   /*!\n Accumulated values for all calls/samples */\n    double sum_squares;   /*!\n Running sum of squares calculation for all\n                              calls/samples */\n    double minimum;       /*!\n Minimum value seen by the timer or counter */\n    double maximum;       /*!\n Maximum value seen by the timer or counter */\n    apex_profile_type type; /*!\n Whether this is a timer or a counter */\n    double papi_metrics[8];  /*!\n Array of accumulated PAPI hardware metrics */\n} apex_profile;\n\n/**\n * The APEX tuning request structures.\n */\n\ntypedef struct _apex_param {\n    char * init_value;          /*!\n Initial value */\n    const char * value;         /*!\n Current value */\n    int num_possible_values;    /*!\n Number of possible values */\n    char * possible_values[];\n} apex_param_struct;\n\ntypedef struct _apex_tuning_request {\n    char * name;                                      /*!\n Tuning request name */\n    double (*metric)(void);                           /*!\n function to return the address of the output parameter */\n    int num_params;                                   /*!\n number of tuning input parameters */\n    char * param_names[];                             /*!\n the input parameter names */\n    apex_param_struct * params[];                     /*!\n the input parameters */\n    apex_event_type trigger;                          /*!\n the event that triggers the tuning update */\n    apex_tuning_session_handle tuning_session_handle; /*!\n the Active Harmony tuning session handle */\n    bool running;                                     /*!\n the current state of the tuning */\n    apex_ah_tuning_strategy strategy;                 /*!\n the requested Active Harmony tuning strategy */\n} apex_tuning_request_struct;\n\n\n\n\nEnvironment variables\n\n\nPlease see the \nenvironment variables\n section of the\ndocumentation. Please note that all environment variables can also be\nqueried or set at runtime with associated API calls. For example, the \nAPEX_CSV_OUTPUT variable can also be set/queried with:\n\n\nvoid apex_set_csv_output (int);\nint apex_get_csv_output (void);\n\n\n\n\nGeneral Utility functions\n\n\nInitialization\n\n\n/* C++ */\nvoid apex::init (const char *thread_name);\n\n\n\n\n/* C */\nvoid apex_init (const char *thread_name);\n\n\n\n\nAPEX initialization is required to set up data structures and spawn the\nnecessary helper threads, including the background system state query thread,\nthe policy engine thread, and the profile handler thread. The thread name\nparameter will be used as the top-level timer for the the main thread of\nexecution.\n\n\nFinalization\n\n\n/* C++ */\nvoid apex::finalize (void);\n\n\n\n\n/* C */\nvoid apex_finalize (void);\n\n\n\n\nAPEX finalization is required to format any desired output (screen, csv,\nprofile, etc.) and terminate all APEX helper threads. No memory is freed at\nthis point - that is done by the \napex_cleanup()\n call.  The reason for this is\nthat applications may want to perform reporting after finalization, so the\nperformance state of the application should still exist. \n\n\nCleanup\n\n\n/* C++ */\nvoid apex::cleanup (void);\n\n\n\n\n/* C */\nvoid apex_cleanup (void);\n\n\n\n\nAPEX cleanup frees all memory associated with APEX. \n\n\nSetting node ID\n\n\n/* C++ */\nvoid apex::set_node_id (const uint64_t id);\n\n\n\n\n/* C */\nvoid apex_set_node_id (const uint64_t id);\n\n\n\n\nWhen running in distributed environments, assign the specified id number as the\nAPEX node ID. This can be an MPI rank or an HPX locality, for example. \n\n\nRegistering threads\n\n\n/* C++ */\nvoid apex::register_thread (const std::string \nname);\n\n\n\n\n/* C */\nvoid apex_register_thread (const char *name);\n\n\n\n\nRegister a new OS thread with APEX.  This method should be called whenever a\nnew OS thread is spawned by the application or the runtime.  An empty string\nor null string is valid input.\n\n\nExiting a thread\n\n\n/* C++ */\nvoid apex::exit_thread (void);\n\n\n\n\n/* C */\nvoid apex_exit_thread (void);\n\n\n\n\nBefore any thread other than the main thread of execution exits, notify APEX\nthat the thread is exiting. The main thread should not call this function, but\napex_finalize instead. Exiting the thread will trigger an event in APEX, so \nany policies associated with a thread exit will be executed.\n\n\nGetting the APEX version\n\n\n/* C++ */\nstd::string \n apex::version (void);\n\n\n\n\n/* C */\nconst char * apex_version (void);\n\n\n\n\nReturn the APEX version as a string.\n\n\nGetting the APEX settings\n\n\n/* C++ */\nstd::string \n apex::get_options (void);\n\n\n\n\n/* C */\nconst char * apex_get_options (void);\n\n\n\n\nReturn the current APEX options as a string.\n\n\nBasic measurement Functions (introspection)\n\n\nStarting a timer\n\n\n/* C++ */\napex_profiler_handle apex::start (const std::string \ntimer_name);\napex_profiler_handle apex::start (const apex_function_address function_address);\n\n\n\n\n/* C */\napex_profiler_handle apex_start (apex_profiler_type type, const void * identifier);\n\n\n\n\nCreate an APEX timer and start it. An APEX profiler object is returned,\ncontaining an identifier that APEX uses to stop the timer.  The timer is either\nidentified by a name or a function/task instruction pointer address.\n\n\nStopping a timer\n\n\n/* C++ */\nvoid apex::stop (apex_profiler_handle the_profiler);\n\n\n\n\n/* C */\nvoid apex_stop (apex_profiler_handle the_profiler);\n\n\n\n\nThe timer associated with the profiler object is stopped and placed on an\ninternal queue to be processed by the profiler handler thread in the\nbackground.  The profiler object is flagged as \"stopped\", so that when the\nprofiler is processed the call count for this particular timer will be\nincremented by 1, \nunless\n the timer was started by \napex_resume()\n (see\nbelow). The profiler handle will be freed internally by APEX after processing.\n\n\nYielding a timer\n\n\n/* C++ */\nvoid apex::yield (apex_profiler_handle the_profiler);\n\n\n\n\n/* C */\nvoid apex_yield (apex_profiler_handle the_profiler);\n\n\n\n\nThe timer associated with the profiler object is stopped and placed on an\ninternal queue to be processed by the profiler handler thread in the\nbackground.  The profiler object is flagged as \nNOT stopped\n, so that when the\nprofiler is processed the call count will NOT be incremented.  An application\nusing apex_yield should not use apex_resume to restart the timer, it should use\napex_start. \napex_yield()\n is intended for situations when the completion state\nof the task is known and the state is \nnot complete\n.\nbelow). The profiler handle will be freed internally by APEX after processing.\n\n\nResuming a timer\n\n\n/* C++ */\napex_profiler_handle apex::resume (const std::string \ntimer_name);\napex_profiler_handle apex::resume (const apex_function_address function_address);\n\n\n\n\n/* C */\napex_profiler_handle apex_resume (apex_profiler_type type, const void * identifier);\n\n\n\n\nCreate an APEX timer and start it. An APEX profiler object is returned,\ncontaining an identifier that APEX uses to stop the timer.  The profiler is\nflagged as \nNOT a new task\n, so that when it is stopped by apex_stop the call\ncount for this particular timer will not be incremented. Apex_resume is intended\nfor situations when the completion state of a task is NOT known when control\nis returned to the task scheduler, but is known when an interrupted task is \nresumed.\n\n\nCreating a new task dependency\n\n\n/* C++ */\nvoid apex::new_task (std::string \n name, const void * task_id);\nvoid apex::new_task (const apex_function_address function_address, const void * task_id);\n\n\n\n\n/* C */\nvoid apex_new_task (apex_profiler_type type, const void * identifier, const void * task_id)\n\n\n\n\nRegister the creation of a new task. This is used to track task dependencies in\nAPEX. APEX assumes that the current APEX profiler refers to the task that is\nthe parent of this new task. The task_info object is a generic pointer to\nwhatever data might need to be passed to a policy executed on when a new task\nis created.\n\n\nSampling a value\n\n\n/* C++ */\nvoid apex::sample_value (const std::string \n name, const double value)\n\n\n\n\n/* C */\nvoid apex_sample_value (const char * name, const double value);\n\n\n\n\nRecord a measurement of the specified counter with the specified value. For\nexample, \"bytes transferred\" and \"1024\".\n\n\nSetting the OS thread state\n\n\n/* C++ */\nvoid apex::set_state (apex_thread_state state);\n\n\n\n\n/* C */\nvoid apex_set_state (apex_thread_state state);\n\n\n\n\nSet the state of the current OS thread.  States can include things like idle,\nbusy, waiting, throttled, blocked.\n\n\nPolicy-related methods (adaptation)\n\n\nRegistering an event-based policy function\n\n\n/* C++ */\napex_policy_handle apex::register_policy (const apex_event_type when, std::function\nint(apex_context const\n)\n f);\nstd::set\napex_policy_handle\n apex::register_policy (std::set\napex_event_type\n when, std::function\nint(apex_context const\n)\n f);\n\n\n\n\n/* C */\napex_policy_handle apex_register_policy (const apex_event_type when, int(*f)(apex_context const\n));\n\n\n\n\nAPEX provides the ability to call an application-specified function when\ncertain events occur in the APEX library, or periodically. This assigns the\npassed in function to the event, so that when that event occurs in APEX, the\nfunction is called. The context for the event will be passed to the registered\nfunction. A set of events can also be used to register a policy function, which will\nreturn a set of policy handles. When any event in the set occurs, the function will\nbe called.\n\n\nRegistering a periodic policy\n\n\n/* C++ */\napex_policy_handle apex::register_periodic_policy(const unsigned long period, std::function\nint(apex_context const\n)\n f);\n\n\n\n\n/* C */\napex_policy_handle apex_register_periodic_policy (const unsigned long period, int(*f)(apex_context const\n));\n\n\n\n\nApex provides the ability to call an application-specified function\nperiodically. This method assigns the passed in function to be called on a\nperiodic basis. The context for the event will be passed to the registered\nfunction.  The period units are in microseconds (us).\n\n\nDe-registering a policy\n\n\n/* C++ */\napex::deregister_policy (apex_policy_handle handle);\n\n\n\n\n/* C */\napex_deregister_policy (apex_policy_handle handle);\n\n\n\n\nRemove the specified policy so that it will no longer be executed, whether it\nis event-based or periodic. The calling code should not try to dereference the\npolicy handle after this call, as the memory pointed to by the handle will be\nfreed.\n\n\nRegistering a custom event\n\n\n/* C++ */\napex_event_type apex::register_custom_event (const std::string \n name);\n\n\n\n\n/* C */\napex_event_type apex_register_custom_event (const char * name);\n\n\n\n\nRegister a new event type with APEX.\n\n\nTrigger a custom event\n\n\n/* C++ */\nvoid apex::custom_event (apex_event_type event_type, const void * event_data);\n\n\n\n\n/* C */\nvoid apex_custom_event (const char * name, const void * event_data);\n\n\n\n\nTrigger a custom event.  This function will pass a custom event to the APEX\nevent listeners. Each listeners' custom event handler will handle the custom\nevent. Policy functions will be passed the custom event name in the event\ncontext.  The event data pointer is to be used to pass memory to the policy\nfunction from the code that triggered the event.\n\n\nRequest a profile from APEX\n\n\n/* C++ */\napex_profile * apex::get_profile (const std::string \n name);\napex_profile * apex::get_profile (const apex_function_address function_address);\n\n\n\n\n/* C */\napex_profile * apex_get_profile (apex_profiler_type type, const void * identifier)\n\n\n\n\nThis function will return the current profile for the specified identifier.\nBecause profiles are updated out-of-band, it is possible that this profile\nvalues are out of date. This profile can be either a timer or a sampled value.\n\n\nReset a profile\n\n\n/* C++ */\nvoid apex::reset (const std::string \n timer_name);\nvoid apex::reset (const apex_function_address function_address);\n\n\n\n\n/* C */\nvoid apex_reset (apex_profiler_type type, const void * identifier)\n\n\n\n\nThis function will reset the profile associated with the specified timer or\ncounter id to zero.  If the identifier is null, all timers and counters will be\nreset.\n\n\nConcurrency Throttling Policy Functions\n\n\nSetup tuning for adaptation\n\n\n/* C++ */\napex_tuning_session_handle setup_custom_tuning(apex_tuning_request \n request);\n\n\n\n\napex_tuning_session_handle setup_custom_tuning(apex_tuning_request * request);\n\n\n\n\nSetup tuning of specified parameters to optimize for a custom metric, using\nmultiple input criteria.  This function will initialize a policy to optimize a\ncustom metric, using the list of tunable parameters. The system tries to\nminimize the custom metric. After evaluating the state of the system, the\npolicy will assign new values to the inputs.\n\n\nGet the current thread cap\n\n\n/* C++ */\nint apex::get_thread_cap (void);\n\n\n\n\n/* C */\nint apex_get_thread_cap (void);\n\n\n\n\nThis function will return the current thread cap based on the throttling policy.\n\n\nSet the current thread cap\n\n\n/* C++ */\nvoid apex::set_thread_cap (int new_cap);\n\n\n\n\n/* C */\nvoid apex_set_thread_cap (int new_cap);\n\n\n\n\nThis function will set the current thread cap based on an external throttling policy.\n\n\nEvent-based API (OCR, Legion support - \nTBD\n)\n\n\nThe OCR and Legion runtimes teams have met to propose a common API for\nmeasuring asynchronous task-based runtimes.\nFor more details, see \nhttps://github.com/khuck/xpress-apex/issues/37\n.\n\n\n/* C++ */\napex::task_create (uint64_t parent_id)\napex::dependency_reached (uint64_t event_id, uint64_t data_id, uint64_t task_id, uint64_t parent_id, ?)\napex::task_ready (uint64_t why_ready)\napex::task_execute (uint64_t why_delay, const apex_function_address function)\napex::task_finished (uint64_t task_id)\napex::task_destroy (uint64_t task_id)\napex::data_create (uint64_t data_id)\napex::data_new_size (uint64_t data_id)\napex::data_move_from (uint64_t data_id, uint64_t target_location)\napex::data_move_to (uint64_t data_id, uint64_t source_location)\napex::data_replace (uint64_t data_id, uint64_t new_id)\napex::data_destroy (uint64_t data_id)\napex::event_create (uint64_t event_id, parent_task_id)\napex::event_add_dependency (uint64_t event_id, uint64_t data_event_task_id, uint64_t parent_task_id)\napex::event_trigger (uint64_t event_id)\napex::event_destroy (uint64_t event_id)\n\n\n\n\n/* C API tbd */", 
            "title": "API Specification"
        }, 
        {
            "location": "/spec/#apex-specification-draft", 
            "text": "...to be fully implemented in a future release.  While the following \nspecification is slightly different than the current implementation,\nthe differences are minor. When in doubt, the current implementation\nis documented by Doxygen, and is available here: http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html  http://www.nic.uoregon.edu/~khuck/apex_docs/doc/refman.pdf", 
            "title": "APEX Specification (DRAFT)"
        }, 
        {
            "location": "/spec/#read-me-first", 
            "text": "The API specification is provided for users who wish to instrument their\nown applications, or who wish to instrument a runtime. Please note that \nthe  HPX , HPX-5  and OpenMP  (using the LLVM OpenMP implementation\nwith draft OMPT support) runtimes have already been instrumented,\nand that users typically do not have to make any calls to the APEX API, other\nthan to add application level timers or to write custom policy rules.", 
            "title": "READ ME FIRST!"
        }, 
        {
            "location": "/spec/#introduction", 
            "text": "This page contains the API specification for APEX. The API specification\nprovides a high-level overview of the API and its functionality. The\nimplementation has Doxygen comments inserted, so for full implementation\ndetails, please see the  API Reference Manual .    A note about C++  The following specification contains both the C and the the C++ API. Typically,\nthe C++ names use overloading for different argument lists, and will replace\nthe  apex_  prefix with the  apex::  namespace. Because both APIs return \nhandles to internal APEX objects, the type definitions of these objects \nuse the C naming convention.  Terminology  Unfortunately, many terms in Computer Science are overloaded. The following definitions are in use in this document:  Thread : an operating system (OS) thread of execution. For example, Posix threads (pthreads).    Task : a scheduled unit of work, such as an OpenMP task or an HPX thread. APEX timers are typically used to measure tasks.  C example  The following is a very small C program that uses the APEX API. For more\nexamples, please see the programs in the  src/examples  and  src/unit_tests/C \ndirectories of the APEX source code.  #include  unistd.h \n#include  stdio.h \n#include  apex.h \n\nint foo(int i) {\n    /* start an APEX timer for the function foo */\n    apex_profiler_handle profiler = apex_start(APEX_FUNCTION_ADDRESS,  foo);\n    int j = i * i;\n    /* stop the APEX timer */\n    apex_stop(profiler);\n    return j;\n}\n\nint main (int argc, char** argv) {\n    /* initialize APEX */\n    apex_init( apex_start unit test );\n    /* start a timer, passing in the address of the main function */\n    apex_profiler_handle profiler = apex_start(APEX_FUNCTION_ADDRESS,  main);\n    int i,j = 0;\n    for (i = 0 ; i   3 ; i++) {\n        j += foo(i);\n    }\n    /* stop the timer */\n    apex_stop(profiler);\n    /* finalize APEX */\n    apex_finalize();\n    /* free all memory allocated by APEX */\n    apex_cleanup();\n    return 0;\n}  C++ example  The following is a slightly more complicated C++ pthread program that uses the\nAPEX API. For more examples, please see the programs in the  src/examples  and src/unit_tests/C++  directories of the APEX source code.  #include  iostream \n#include  pthread.h \n#include  unistd.h \n#include  apex_api.hpp \n\nvoid* someThread(void* tmp)\n{\n    int* tid = (int*)tmp;\n    char name[32];\n    sprintf(name,  worker thread %d , *tid);\n    /* Register this thread with APEX */\n    apex::register_thread(name);\n    /* Start a timer */\n    apex::profiler* p = apex::start((apex_function_address) someThread);\n    /* ... */\n    /* do some computation */\n    /* ... */\n    /* stop the timer */\n    apex::stop(p);\n    /* tell APEX that this thread is exiting */\n    apex::exit_thread();\n    return NULL;\n}\n\nint main (int argc, char** argv) {\n    /* initialize APEX */\n    apex::init( apex::start unit test );\n    /* set our node ID */\n    apex::set_node_id(0);\n    /* start a timer */\n    apex::profiler* p = apex::start( main );\n    /* Spawn two threads */\n    pthread_t thread[2];\n    int tid = 0;\n    pthread_create( (thread[0]), NULL, someThread,  tid);\n    int tid2 = 1;\n    pthread_create( (thread[1]), NULL, someThread,  tid2);\n    /* wait for the threads to finish */\n    pthread_join(thread[0], NULL);\n    pthread_join(thread[1], NULL);\n    /* stop our main timer */\n    apex::stop(p);\n    /* finalize APEX */\n    apex::finalize();\n    /* free all memory allocated by APEX */\n    apex::cleanup();\n    return 0;\n}", 
            "title": "Introduction"
        }, 
        {
            "location": "/spec/#constants-types-and-enumerations", 
            "text": "Constants  /** A null pointer representing an APEX profiler handle.\n * Used when a null APEX profile handle is to be passed in to\n * apex::stop when the profiler object was not retained locally.\n */\n#define APEX_NULL_PROFILER_HANDLE (apex_profiler_handle)(NULL) // for comparisons\n\n#define APEX_MAX_EVENTS 128 /*!  The maximum number of event types. Allows for ~20 custom events. */\n\n#define APEX_NULL_FUNCTION_ADDRESS 0L // for comparisons  Pre-defined types  /** The address of a C++ object in APEX.\n * Not useful for the caller that gets it back, but required\n * for stopping the timer later.\n */\ntypedef uintptr_t apex_profiler_handle; // address of internal C++ object\n\n/** Not useful for the caller that gets it back, but required\n * for deregistering policies after registration.\n */\ntypedef uintptr_t apex_policy_handle; // address of internal C++ object\n\n/** Rather than use void pointers everywhere, be explicit about\n * what the functions are expecting.\n */\ntypedef uintptr_t apex_function_address; // generic function pointer  Enumerations  /**\n * Typedef for enumerating the different timer types\n */\ntypedef enum _apex_profiler_type {\n    APEX_FUNCTION_ADDRESS = 0, /*!  The ID is a function (or instruction) address */\n    APEX_NAME_STRING,          /*!  The ID is a character string */\n    APEX_FUNCTOR               /*!  C++ Object with the () operator defined */\n} apex_profiler_type;\n\n/**\n * Typedef for enumerating the different event types\n */\ntypedef enum _event_type {\n  APEX_INVALID_EVENT = -1,\n  APEX_STARTUP = 0,        /*!  APEX is initialized */\n  APEX_SHUTDOWN,       /*!  APEX is terminated */\n  APEX_NEW_NODE,       /*!  APEX has registered a new process ID */\n  APEX_NEW_THREAD,     /*!  APEX has registered a new OS thread */\n  APEX_EXIT_THREAD,    /*!  APEX has exited an OS thread */\n  APEX_START_EVENT,    /*!  APEX has processed a timer start event */\n  APEX_RESUME_EVENT,   /*!  APEX has processed a timer resume event (the number\n                           of calls is not incremented) */\n  APEX_STOP_EVENT,     /*!  APEX has processed a timer stop event */\n  APEX_YIELD_EVENT,    /*!  APEX has processed a timer yield event */\n  APEX_SAMPLE_VALUE,   /*!  APEX has processed a sampled value */\n  APEX_PERIODIC,       /*!  APEX has processed a periodic timer */\n  APEX_CUSTOM_EVENT_1,   /*!  APEX has processed a custom event - useful for large\n                           granularity application control events */\n  APEX_CUSTOM_EVENT_2, // these are just here for padding, and so we can\n  APEX_CUSTOM_EVENT_3, // test with them.\n  APEX_CUSTOM_EVENT_4,\n  APEX_CUSTOM_EVENT_5,\n  APEX_CUSTOM_EVENT_6,\n  APEX_CUSTOM_EVENT_7,\n  APEX_CUSTOM_EVENT_8,\n  APEX_UNUSED_EVENT = APEX_MAX_EVENTS // can't have more custom events than this\n} apex_event_type;\n\n/** \n * Typedef for enumerating the OS thread states. \n */\ntypedef enum _thread_state {\n    APEX_IDLE,          /*!  Thread is idle */\n    APEX_BUSY,          /*!  Thread is working */\n    APEX_THROTTLED,     /*!  Thread is throttled (sleeping) */\n    APEX_WAITING,       /*!  Thread is waiting for a resource */\n    APEX_BLOCKED        /*!  Thread is otherwise blocked */\n} apex_thread_state;\n\n/**\n * Typedef for enumerating the different optimization strategies\n * for throttling.\n */\ntypedef enum {APEX_MAXIMIZE_THROUGHPUT,   /*!  maximize the number of calls to a\n                                              timer/counter */\n              APEX_MAXIMIZE_ACCUMULATED,  /*!  maximize the accumulated value of\n                                              a timer/counter */\n              APEX_MINIMIZE_ACCUMULATED   /*!  minimize the accumulated value of\n                                              a timer/counter */\n} apex_optimization_criteria_t;\n\n/**\n * Typedef for enumerating the different optimization methods\n * for throttling.\n */\ntypedef enum {APEX_SIMPLE_HYSTERESIS,      /*!  optimize using sliding window of\n                                               historical observations. A running\n                                               average of the most recent N observations\n                                               are used as the measurement. */\n              APEX_DISCRETE_HILL_CLIMBING, /*!  Use a discrete hill climbing algorithm\n                                               for optimization */\n              APEX_ACTIVE_HARMONY          /*!  Use Active Harmony for optimization. */\n} apex_optimization_method_t;\n\n/** The type of a profiler object\n * \n */\ntypedef enum _profile_type {\n  APEX_TIMER,        /*!  This profile is a instrumented timer */\n  APEX_COUNTER       /*!  This profile is a sampled counter */\n} apex_profile_type;", 
            "title": "Constants, types and enumerations"
        }, 
        {
            "location": "/spec/#data-structures-and-classes", 
            "text": "/** \n * The APEX context when an event occurs. This context will be passed to \n * any policies registered for this event.\n */\ntypedef struct _context {\n    apex_event_type event_type;        /*!  The type of the event currently\n                                           processing */\n    apex_policy_handle* policy_handle; /*!  The policy handle for the current\n                                           policy function */\n    void * data;  /*!  Data associated with the event, such as the custom_data\n                       for a custom_event */\n} apex_context;\n\n/**\n * The profile object for a timer in APEX. \n * Returned by the apex_get_profile() call.\n */\ntypedef struct _profile {\n    double calls;         /*!  Number of times a timer was called, or the number\n                              of samples collected for a counter */\n    double accumulated;   /*!  Accumulated values for all calls/samples */\n    double sum_squares;   /*!  Running sum of squares calculation for all\n                              calls/samples */\n    double minimum;       /*!  Minimum value seen by the timer or counter */\n    double maximum;       /*!  Maximum value seen by the timer or counter */\n    apex_profile_type type; /*!  Whether this is a timer or a counter */\n    double papi_metrics[8];  /*!  Array of accumulated PAPI hardware metrics */\n} apex_profile;\n\n/**\n * The APEX tuning request structures.\n */\n\ntypedef struct _apex_param {\n    char * init_value;          /*!  Initial value */\n    const char * value;         /*!  Current value */\n    int num_possible_values;    /*!  Number of possible values */\n    char * possible_values[];\n} apex_param_struct;\n\ntypedef struct _apex_tuning_request {\n    char * name;                                      /*!  Tuning request name */\n    double (*metric)(void);                           /*!  function to return the address of the output parameter */\n    int num_params;                                   /*!  number of tuning input parameters */\n    char * param_names[];                             /*!  the input parameter names */\n    apex_param_struct * params[];                     /*!  the input parameters */\n    apex_event_type trigger;                          /*!  the event that triggers the tuning update */\n    apex_tuning_session_handle tuning_session_handle; /*!  the Active Harmony tuning session handle */\n    bool running;                                     /*!  the current state of the tuning */\n    apex_ah_tuning_strategy strategy;                 /*!  the requested Active Harmony tuning strategy */\n} apex_tuning_request_struct;", 
            "title": "Data structures and classes"
        }, 
        {
            "location": "/spec/#environment-variables", 
            "text": "Please see the  environment variables  section of the\ndocumentation. Please note that all environment variables can also be\nqueried or set at runtime with associated API calls. For example, the \nAPEX_CSV_OUTPUT variable can also be set/queried with:  void apex_set_csv_output (int);\nint apex_get_csv_output (void);", 
            "title": "Environment variables"
        }, 
        {
            "location": "/spec/#general-utility-functions", 
            "text": "Initialization  /* C++ */\nvoid apex::init (const char *thread_name);  /* C */\nvoid apex_init (const char *thread_name);  APEX initialization is required to set up data structures and spawn the\nnecessary helper threads, including the background system state query thread,\nthe policy engine thread, and the profile handler thread. The thread name\nparameter will be used as the top-level timer for the the main thread of\nexecution.  Finalization  /* C++ */\nvoid apex::finalize (void);  /* C */\nvoid apex_finalize (void);  APEX finalization is required to format any desired output (screen, csv,\nprofile, etc.) and terminate all APEX helper threads. No memory is freed at\nthis point - that is done by the  apex_cleanup()  call.  The reason for this is\nthat applications may want to perform reporting after finalization, so the\nperformance state of the application should still exist.   Cleanup  /* C++ */\nvoid apex::cleanup (void);  /* C */\nvoid apex_cleanup (void);  APEX cleanup frees all memory associated with APEX.   Setting node ID  /* C++ */\nvoid apex::set_node_id (const uint64_t id);  /* C */\nvoid apex_set_node_id (const uint64_t id);  When running in distributed environments, assign the specified id number as the\nAPEX node ID. This can be an MPI rank or an HPX locality, for example.   Registering threads  /* C++ */\nvoid apex::register_thread (const std::string  name);  /* C */\nvoid apex_register_thread (const char *name);  Register a new OS thread with APEX.  This method should be called whenever a\nnew OS thread is spawned by the application or the runtime.  An empty string\nor null string is valid input.  Exiting a thread  /* C++ */\nvoid apex::exit_thread (void);  /* C */\nvoid apex_exit_thread (void);  Before any thread other than the main thread of execution exits, notify APEX\nthat the thread is exiting. The main thread should not call this function, but\napex_finalize instead. Exiting the thread will trigger an event in APEX, so \nany policies associated with a thread exit will be executed.  Getting the APEX version  /* C++ */\nstd::string   apex::version (void);  /* C */\nconst char * apex_version (void);  Return the APEX version as a string.  Getting the APEX settings  /* C++ */\nstd::string   apex::get_options (void);  /* C */\nconst char * apex_get_options (void);  Return the current APEX options as a string.", 
            "title": "General Utility functions"
        }, 
        {
            "location": "/spec/#basic-measurement-functions-introspection", 
            "text": "Starting a timer  /* C++ */\napex_profiler_handle apex::start (const std::string  timer_name);\napex_profiler_handle apex::start (const apex_function_address function_address);  /* C */\napex_profiler_handle apex_start (apex_profiler_type type, const void * identifier);  Create an APEX timer and start it. An APEX profiler object is returned,\ncontaining an identifier that APEX uses to stop the timer.  The timer is either\nidentified by a name or a function/task instruction pointer address.  Stopping a timer  /* C++ */\nvoid apex::stop (apex_profiler_handle the_profiler);  /* C */\nvoid apex_stop (apex_profiler_handle the_profiler);  The timer associated with the profiler object is stopped and placed on an\ninternal queue to be processed by the profiler handler thread in the\nbackground.  The profiler object is flagged as \"stopped\", so that when the\nprofiler is processed the call count for this particular timer will be\nincremented by 1,  unless  the timer was started by  apex_resume()  (see\nbelow). The profiler handle will be freed internally by APEX after processing.  Yielding a timer  /* C++ */\nvoid apex::yield (apex_profiler_handle the_profiler);  /* C */\nvoid apex_yield (apex_profiler_handle the_profiler);  The timer associated with the profiler object is stopped and placed on an\ninternal queue to be processed by the profiler handler thread in the\nbackground.  The profiler object is flagged as  NOT stopped , so that when the\nprofiler is processed the call count will NOT be incremented.  An application\nusing apex_yield should not use apex_resume to restart the timer, it should use\napex_start.  apex_yield()  is intended for situations when the completion state\nof the task is known and the state is  not complete .\nbelow). The profiler handle will be freed internally by APEX after processing.  Resuming a timer  /* C++ */\napex_profiler_handle apex::resume (const std::string  timer_name);\napex_profiler_handle apex::resume (const apex_function_address function_address);  /* C */\napex_profiler_handle apex_resume (apex_profiler_type type, const void * identifier);  Create an APEX timer and start it. An APEX profiler object is returned,\ncontaining an identifier that APEX uses to stop the timer.  The profiler is\nflagged as  NOT a new task , so that when it is stopped by apex_stop the call\ncount for this particular timer will not be incremented. Apex_resume is intended\nfor situations when the completion state of a task is NOT known when control\nis returned to the task scheduler, but is known when an interrupted task is \nresumed.  Creating a new task dependency  /* C++ */\nvoid apex::new_task (std::string   name, const void * task_id);\nvoid apex::new_task (const apex_function_address function_address, const void * task_id);  /* C */\nvoid apex_new_task (apex_profiler_type type, const void * identifier, const void * task_id)  Register the creation of a new task. This is used to track task dependencies in\nAPEX. APEX assumes that the current APEX profiler refers to the task that is\nthe parent of this new task. The task_info object is a generic pointer to\nwhatever data might need to be passed to a policy executed on when a new task\nis created.  Sampling a value  /* C++ */\nvoid apex::sample_value (const std::string   name, const double value)  /* C */\nvoid apex_sample_value (const char * name, const double value);  Record a measurement of the specified counter with the specified value. For\nexample, \"bytes transferred\" and \"1024\".  Setting the OS thread state  /* C++ */\nvoid apex::set_state (apex_thread_state state);  /* C */\nvoid apex_set_state (apex_thread_state state);  Set the state of the current OS thread.  States can include things like idle,\nbusy, waiting, throttled, blocked.", 
            "title": "Basic measurement Functions (introspection)"
        }, 
        {
            "location": "/spec/#policy-related-methods-adaptation", 
            "text": "Registering an event-based policy function  /* C++ */\napex_policy_handle apex::register_policy (const apex_event_type when, std::function int(apex_context const )  f);\nstd::set apex_policy_handle  apex::register_policy (std::set apex_event_type  when, std::function int(apex_context const )  f);  /* C */\napex_policy_handle apex_register_policy (const apex_event_type when, int(*f)(apex_context const ));  APEX provides the ability to call an application-specified function when\ncertain events occur in the APEX library, or periodically. This assigns the\npassed in function to the event, so that when that event occurs in APEX, the\nfunction is called. The context for the event will be passed to the registered\nfunction. A set of events can also be used to register a policy function, which will\nreturn a set of policy handles. When any event in the set occurs, the function will\nbe called.  Registering a periodic policy  /* C++ */\napex_policy_handle apex::register_periodic_policy(const unsigned long period, std::function int(apex_context const )  f);  /* C */\napex_policy_handle apex_register_periodic_policy (const unsigned long period, int(*f)(apex_context const ));  Apex provides the ability to call an application-specified function\nperiodically. This method assigns the passed in function to be called on a\nperiodic basis. The context for the event will be passed to the registered\nfunction.  The period units are in microseconds (us).  De-registering a policy  /* C++ */\napex::deregister_policy (apex_policy_handle handle);  /* C */\napex_deregister_policy (apex_policy_handle handle);  Remove the specified policy so that it will no longer be executed, whether it\nis event-based or periodic. The calling code should not try to dereference the\npolicy handle after this call, as the memory pointed to by the handle will be\nfreed.  Registering a custom event  /* C++ */\napex_event_type apex::register_custom_event (const std::string   name);  /* C */\napex_event_type apex_register_custom_event (const char * name);  Register a new event type with APEX.  Trigger a custom event  /* C++ */\nvoid apex::custom_event (apex_event_type event_type, const void * event_data);  /* C */\nvoid apex_custom_event (const char * name, const void * event_data);  Trigger a custom event.  This function will pass a custom event to the APEX\nevent listeners. Each listeners' custom event handler will handle the custom\nevent. Policy functions will be passed the custom event name in the event\ncontext.  The event data pointer is to be used to pass memory to the policy\nfunction from the code that triggered the event.  Request a profile from APEX  /* C++ */\napex_profile * apex::get_profile (const std::string   name);\napex_profile * apex::get_profile (const apex_function_address function_address);  /* C */\napex_profile * apex_get_profile (apex_profiler_type type, const void * identifier)  This function will return the current profile for the specified identifier.\nBecause profiles are updated out-of-band, it is possible that this profile\nvalues are out of date. This profile can be either a timer or a sampled value.  Reset a profile  /* C++ */\nvoid apex::reset (const std::string   timer_name);\nvoid apex::reset (const apex_function_address function_address);  /* C */\nvoid apex_reset (apex_profiler_type type, const void * identifier)  This function will reset the profile associated with the specified timer or\ncounter id to zero.  If the identifier is null, all timers and counters will be\nreset.", 
            "title": "Policy-related methods (adaptation)"
        }, 
        {
            "location": "/spec/#concurrency-throttling-policy-functions", 
            "text": "Setup tuning for adaptation  /* C++ */\napex_tuning_session_handle setup_custom_tuning(apex_tuning_request   request);  apex_tuning_session_handle setup_custom_tuning(apex_tuning_request * request);  Setup tuning of specified parameters to optimize for a custom metric, using\nmultiple input criteria.  This function will initialize a policy to optimize a\ncustom metric, using the list of tunable parameters. The system tries to\nminimize the custom metric. After evaluating the state of the system, the\npolicy will assign new values to the inputs.  Get the current thread cap  /* C++ */\nint apex::get_thread_cap (void);  /* C */\nint apex_get_thread_cap (void);  This function will return the current thread cap based on the throttling policy.  Set the current thread cap  /* C++ */\nvoid apex::set_thread_cap (int new_cap);  /* C */\nvoid apex_set_thread_cap (int new_cap);  This function will set the current thread cap based on an external throttling policy.", 
            "title": "Concurrency Throttling Policy Functions"
        }, 
        {
            "location": "/spec/#event-based-api-ocr-legion-support-tbd", 
            "text": "The OCR and Legion runtimes teams have met to propose a common API for\nmeasuring asynchronous task-based runtimes.\nFor more details, see  https://github.com/khuck/xpress-apex/issues/37 .  /* C++ */\napex::task_create (uint64_t parent_id)\napex::dependency_reached (uint64_t event_id, uint64_t data_id, uint64_t task_id, uint64_t parent_id, ?)\napex::task_ready (uint64_t why_ready)\napex::task_execute (uint64_t why_delay, const apex_function_address function)\napex::task_finished (uint64_t task_id)\napex::task_destroy (uint64_t task_id)\napex::data_create (uint64_t data_id)\napex::data_new_size (uint64_t data_id)\napex::data_move_from (uint64_t data_id, uint64_t target_location)\napex::data_move_to (uint64_t data_id, uint64_t source_location)\napex::data_replace (uint64_t data_id, uint64_t new_id)\napex::data_destroy (uint64_t data_id)\napex::event_create (uint64_t event_id, parent_task_id)\napex::event_add_dependency (uint64_t event_id, uint64_t data_event_task_id, uint64_t parent_task_id)\napex::event_trigger (uint64_t event_id)\napex::event_destroy (uint64_t event_id)  /* C API tbd */", 
            "title": "Event-based API (OCR, Legion support - TBD)"
        }, 
        {
            "location": "/refman/", 
            "text": "API Doxygen Reference\n\n\nThe source code is instrumented with Doxygen comments, and the API reference\nmanual can be generated by executing 'make doc' in the build directory, after\nCMake configuration.  A fairly recent version of the API reference\ndocumentation is available here:\n\nhttp://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html\n\n\nhttp://www.nic.uoregon.edu/~khuck/apex_docs/doc/refman.pdf\n\n\nIn the event that the \nAPI specification\n and the reference implementation\n(as generated by the Doxygen comments from the actual source code) do\nnot match, assume that the specification is correct and that the implementation\nis non-compliant - and subsequently contact the project maintainers so that\nwe may bring the implementation into compliance.", 
            "title": "API Doxygen Reference"
        }, 
        {
            "location": "/refman/#api-doxygen-reference", 
            "text": "The source code is instrumented with Doxygen comments, and the API reference\nmanual can be generated by executing 'make doc' in the build directory, after\nCMake configuration.  A fairly recent version of the API reference\ndocumentation is available here: http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html  http://www.nic.uoregon.edu/~khuck/apex_docs/doc/refman.pdf  In the event that the  API specification  and the reference implementation\n(as generated by the Doxygen comments from the actual source code) do\nnot match, assume that the specification is correct and that the implementation\nis non-compliant - and subsequently contact the project maintainers so that\nwe may bring the implementation into compliance.", 
            "title": "API Doxygen Reference"
        }
    ]
}